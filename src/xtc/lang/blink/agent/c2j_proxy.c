/* This source file is generated by GenerateJNIFunctionProxy.java.Please, do not edit manually.*/
#include <assert.h>
#include <jni.h>
#include <jvmti.h>
#include "state.h"
#include "common.h"
#include "agent.h"
#include "options.h"
#include "java_method.h"
#include "jnicheck.h"
#include "classfile_constants.h"

struct bda_c2j_stat {
  int GetVersion;
  int DefineClass;
  int FindClass;
  int FromReflectedMethod;
  int FromReflectedField;
  int ToReflectedMethod;
  int GetSuperclass;
  int IsAssignableFrom;
  int ToReflectedField;
  int Throw;
  int ThrowNew;
  int ExceptionOccurred;
  int ExceptionDescribe;
  int ExceptionClear;
  int FatalError;
  int PushLocalFrame;
  int PopLocalFrame;
  int NewGlobalRef;
  int DeleteGlobalRef;
  int DeleteLocalRef;
  int IsSameObject;
  int NewLocalRef;
  int EnsureLocalCapacity;
  int AllocObject;
  int NewObject;
  int NewObjectV;
  int NewObjectA;
  int GetObjectClass;
  int IsInstanceOf;
  int GetMethodID;
  int CallObjectMethod;
  int CallObjectMethodV;
  int CallObjectMethodA;
  int CallBooleanMethod;
  int CallBooleanMethodV;
  int CallBooleanMethodA;
  int CallByteMethod;
  int CallByteMethodV;
  int CallByteMethodA;
  int CallCharMethod;
  int CallCharMethodV;
  int CallCharMethodA;
  int CallShortMethod;
  int CallShortMethodV;
  int CallShortMethodA;
  int CallIntMethod;
  int CallIntMethodV;
  int CallIntMethodA;
  int CallLongMethod;
  int CallLongMethodV;
  int CallLongMethodA;
  int CallFloatMethod;
  int CallFloatMethodV;
  int CallFloatMethodA;
  int CallDoubleMethod;
  int CallDoubleMethodV;
  int CallDoubleMethodA;
  int CallVoidMethod;
  int CallVoidMethodV;
  int CallVoidMethodA;
  int CallNonvirtualObjectMethod;
  int CallNonvirtualObjectMethodV;
  int CallNonvirtualObjectMethodA;
  int CallNonvirtualBooleanMethod;
  int CallNonvirtualBooleanMethodV;
  int CallNonvirtualBooleanMethodA;
  int CallNonvirtualByteMethod;
  int CallNonvirtualByteMethodV;
  int CallNonvirtualByteMethodA;
  int CallNonvirtualCharMethod;
  int CallNonvirtualCharMethodV;
  int CallNonvirtualCharMethodA;
  int CallNonvirtualShortMethod;
  int CallNonvirtualShortMethodV;
  int CallNonvirtualShortMethodA;
  int CallNonvirtualIntMethod;
  int CallNonvirtualIntMethodV;
  int CallNonvirtualIntMethodA;
  int CallNonvirtualLongMethod;
  int CallNonvirtualLongMethodV;
  int CallNonvirtualLongMethodA;
  int CallNonvirtualFloatMethod;
  int CallNonvirtualFloatMethodV;
  int CallNonvirtualFloatMethodA;
  int CallNonvirtualDoubleMethod;
  int CallNonvirtualDoubleMethodV;
  int CallNonvirtualDoubleMethodA;
  int CallNonvirtualVoidMethod;
  int CallNonvirtualVoidMethodV;
  int CallNonvirtualVoidMethodA;
  int GetFieldID;
  int GetObjectField;
  int GetBooleanField;
  int GetByteField;
  int GetCharField;
  int GetShortField;
  int GetIntField;
  int GetLongField;
  int GetFloatField;
  int GetDoubleField;
  int SetObjectField;
  int SetBooleanField;
  int SetByteField;
  int SetCharField;
  int SetShortField;
  int SetIntField;
  int SetLongField;
  int SetFloatField;
  int SetDoubleField;
  int GetStaticMethodID;
  int CallStaticObjectMethod;
  int CallStaticObjectMethodV;
  int CallStaticObjectMethodA;
  int CallStaticBooleanMethod;
  int CallStaticBooleanMethodV;
  int CallStaticBooleanMethodA;
  int CallStaticByteMethod;
  int CallStaticByteMethodV;
  int CallStaticByteMethodA;
  int CallStaticCharMethod;
  int CallStaticCharMethodV;
  int CallStaticCharMethodA;
  int CallStaticShortMethod;
  int CallStaticShortMethodV;
  int CallStaticShortMethodA;
  int CallStaticIntMethod;
  int CallStaticIntMethodV;
  int CallStaticIntMethodA;
  int CallStaticLongMethod;
  int CallStaticLongMethodV;
  int CallStaticLongMethodA;
  int CallStaticFloatMethod;
  int CallStaticFloatMethodV;
  int CallStaticFloatMethodA;
  int CallStaticDoubleMethod;
  int CallStaticDoubleMethodV;
  int CallStaticDoubleMethodA;
  int CallStaticVoidMethod;
  int CallStaticVoidMethodV;
  int CallStaticVoidMethodA;
  int GetStaticFieldID;
  int GetStaticObjectField;
  int GetStaticBooleanField;
  int GetStaticByteField;
  int GetStaticCharField;
  int GetStaticShortField;
  int GetStaticIntField;
  int GetStaticLongField;
  int GetStaticFloatField;
  int GetStaticDoubleField;
  int SetStaticObjectField;
  int SetStaticBooleanField;
  int SetStaticByteField;
  int SetStaticCharField;
  int SetStaticShortField;
  int SetStaticIntField;
  int SetStaticLongField;
  int SetStaticFloatField;
  int SetStaticDoubleField;
  int NewString;
  int GetStringLength;
  int GetStringChars;
  int ReleaseStringChars;
  int NewStringUTF;
  int GetStringUTFLength;
  int GetStringUTFChars;
  int ReleaseStringUTFChars;
  int GetArrayLength;
  int NewObjectArray;
  int GetObjectArrayElement;
  int SetObjectArrayElement;
  int NewBooleanArray;
  int NewByteArray;
  int NewCharArray;
  int NewShortArray;
  int NewIntArray;
  int NewLongArray;
  int NewFloatArray;
  int NewDoubleArray;
  int GetBooleanArrayElements;
  int GetByteArrayElements;
  int GetCharArrayElements;
  int GetShortArrayElements;
  int GetIntArrayElements;
  int GetLongArrayElements;
  int GetFloatArrayElements;
  int GetDoubleArrayElements;
  int ReleaseBooleanArrayElements;
  int ReleaseByteArrayElements;
  int ReleaseCharArrayElements;
  int ReleaseShortArrayElements;
  int ReleaseIntArrayElements;
  int ReleaseLongArrayElements;
  int ReleaseFloatArrayElements;
  int ReleaseDoubleArrayElements;
  int GetBooleanArrayRegion;
  int GetByteArrayRegion;
  int GetCharArrayRegion;
  int GetShortArrayRegion;
  int GetIntArrayRegion;
  int GetLongArrayRegion;
  int GetFloatArrayRegion;
  int GetDoubleArrayRegion;
  int SetBooleanArrayRegion;
  int SetByteArrayRegion;
  int SetCharArrayRegion;
  int SetShortArrayRegion;
  int SetIntArrayRegion;
  int SetLongArrayRegion;
  int SetFloatArrayRegion;
  int SetDoubleArrayRegion;
  int RegisterNatives;
  int UnregisterNatives;
  int MonitorEnter;
  int MonitorExit;
  int GetJavaVM;
  int GetStringRegion;
  int GetStringUTFRegion;
  int GetPrimitiveArrayCritical;
  int ReleasePrimitiveArrayCritical;
  int GetStringCritical;
  int ReleaseStringCritical;
  int NewWeakGlobalRef;
  int DeleteWeakGlobalRef;
  int ExceptionCheck;
  int NewDirectByteBuffer;
  int GetDirectBufferAddress;
  int GetDirectBufferCapacity;
  int GetObjectRefType;
};
static jniNativeInterface* proxy_jni_funcs = NULL;
struct bda_c2j_stat bda_c2j_count;
struct bda_c2j_stat bda_c2j_count_user;

/* proxy for GetVersion*/
static jint JNICALL bda_c2j_proxy_GetVersion(JNIEnv * env)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetVersion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetVersion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetVersion")
    && bda_check_no_exeception(s, "GetVersion")
    && bda_check_no_critical(s, "GetVersion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetVersion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetVersion", s->name)) {
    printf("=> %-50s %p(JNIEnv *)\n", "GetVersion" , env);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetVersion(env);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetVersion", s->name)) {
    printf("<= %-50s %d\n", "GetVersion", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for DefineClass*/
static jclass JNICALL bda_c2j_proxy_DefineClass(JNIEnv * env, const char * p1, jobject p2, const jbyte * p3, jsize p4)
{
  /* local variables */
  jclass result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.DefineClass++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.DefineClass++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "DefineClass")
    && bda_check_no_exeception(s, "DefineClass")
    && bda_check_capacity_c2j_call(s, "DefineClass")
    && bda_check_no_critical(s, "DefineClass")
    && bda_check_non_null(s, p1,  1, "DefineClass")
    && bda_check_non_null(s, p2,  2, "DefineClass")
    && bda_check_non_null(s, p3,  3, "DefineClass")
    && bda_check_dref(s, p2, 2, "DefineClass")
    && bda_check_subclass_jobject_jclass(s, p2, bda_clazz_classloader, 2, "DefineClass")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_DefineClass;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("DefineClass", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %s(const char *) %p(jobject) %s(const jbyte *) %d(jsize)\n", "DefineClass" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->DefineClass(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("DefineClass", s->name)) {
    printf("<= %-50s %p\n", "DefineClass", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for FindClass*/
static jclass JNICALL bda_c2j_proxy_FindClass(JNIEnv * env, const char * p1)
{
  /* local variables */
  jclass result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.FindClass++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.FindClass++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "FindClass")
    && bda_check_no_exeception(s, "FindClass")
    && bda_check_capacity_c2j_call(s, "FindClass")
    && bda_check_no_critical(s, "FindClass")
    && bda_check_non_null(s, p1,  1, "FindClass")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_FindClass;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("FindClass", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %s(const char *)\n", "FindClass" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->FindClass(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("FindClass", s->name)) {
    printf("<= %-50s %p\n", "FindClass", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for FromReflectedMethod*/
static jmethodID JNICALL bda_c2j_proxy_FromReflectedMethod(JNIEnv * env, jobject p1)
{
  /* local variables */
  jmethodID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.FromReflectedMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.FromReflectedMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "FromReflectedMethod")
    && bda_check_no_exeception(s, "FromReflectedMethod")
    && bda_check_no_critical(s, "FromReflectedMethod")
    && bda_check_non_null(s, p1,  1, "FromReflectedMethod")
    && bda_check_dref(s, p1, 1, "FromReflectedMethod")
    && bda_check_jobject_reflected_method(s, p1, 1, "FromReflectedMethod")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_FromReflectedMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("FromReflectedMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "FromReflectedMethod" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->FromReflectedMethod(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("FromReflectedMethod", s->name)) {
    printf("<= %-50s %p\n", "FromReflectedMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for FromReflectedField*/
static jfieldID JNICALL bda_c2j_proxy_FromReflectedField(JNIEnv * env, jobject p1)
{
  /* local variables */
  jfieldID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.FromReflectedField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.FromReflectedField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "FromReflectedField")
    && bda_check_no_exeception(s, "FromReflectedField")
    && bda_check_no_critical(s, "FromReflectedField")
    && bda_check_non_null(s, p1,  1, "FromReflectedField")
    && bda_check_dref(s, p1, 1, "FromReflectedField")
    && bda_check_instance_jobject_jclass(s, p1, bda_clazz_field, 1, "FromReflectedField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_FromReflectedField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("FromReflectedField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "FromReflectedField" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->FromReflectedField(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("FromReflectedField", s->name)) {
    printf("<= %-50s %p\n", "FromReflectedField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for ToReflectedMethod*/
static jobject JNICALL bda_c2j_proxy_ToReflectedMethod(JNIEnv * env, jclass p1, jmethodID p2, jboolean p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ToReflectedMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ToReflectedMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ToReflectedMethod")
    && bda_check_no_exeception(s, "ToReflectedMethod")
    && bda_check_capacity_c2j_call(s, "ToReflectedMethod")
    && bda_check_no_critical(s, "ToReflectedMethod")
    && bda_check_non_null(s, p1,  1, "ToReflectedMethod")
    && bda_check_non_null(s, p2,  2, "ToReflectedMethod")
    && bda_check_dref(s, p1, 1, "ToReflectedMethod")
    && bda_check_jclass(s, p1, 1, "ToReflectedMethod")
    && bda_check_jmethodid_to_reflected(s, p1, p2, p3, "ToReflectedMethod")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ToReflectedMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ToReflectedMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %d(jboolean)\n", "ToReflectedMethod" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ToReflectedMethod(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ToReflectedMethod", s->name)) {
    printf("<= %-50s %p\n", "ToReflectedMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for GetSuperclass*/
static jclass JNICALL bda_c2j_proxy_GetSuperclass(JNIEnv * env, jclass p1)
{
  /* local variables */
  jclass result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetSuperclass++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetSuperclass++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetSuperclass")
    && bda_check_no_exeception(s, "GetSuperclass")
    && bda_check_capacity_c2j_call(s, "GetSuperclass")
    && bda_check_no_critical(s, "GetSuperclass")
    && bda_check_non_null(s, p1,  1, "GetSuperclass")
    && bda_check_dref(s, p1, 1, "GetSuperclass")
    && bda_check_jclass(s, p1, 1, "GetSuperclass")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetSuperclass;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetSuperclass", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass)\n", "GetSuperclass" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetSuperclass(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetSuperclass", s->name)) {
    printf("<= %-50s %p\n", "GetSuperclass", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for IsAssignableFrom*/
static jboolean JNICALL bda_c2j_proxy_IsAssignableFrom(JNIEnv * env, jclass p1, jclass p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.IsAssignableFrom++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.IsAssignableFrom++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "IsAssignableFrom")
    && bda_check_no_exeception(s, "IsAssignableFrom")
    && bda_check_no_critical(s, "IsAssignableFrom")
    && bda_check_non_null(s, p1,  1, "IsAssignableFrom")
    && bda_check_non_null(s, p2,  2, "IsAssignableFrom")
    && bda_check_dref(s, p1, 1, "IsAssignableFrom")
    && bda_check_jclass(s, p1, 1, "IsAssignableFrom")
    && bda_check_dref(s, p2, 2, "IsAssignableFrom")
    && bda_check_jclass(s, p2, 2, "IsAssignableFrom")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_IsAssignableFrom;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("IsAssignableFrom", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jclass)\n", "IsAssignableFrom" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->IsAssignableFrom(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("IsAssignableFrom", s->name)) {
    printf("<= %-50s %d\n", "IsAssignableFrom", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for ToReflectedField*/
static jobject JNICALL bda_c2j_proxy_ToReflectedField(JNIEnv * env, jclass p1, jfieldID p2, jboolean p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ToReflectedField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ToReflectedField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ToReflectedField")
    && bda_check_no_exeception(s, "ToReflectedField")
    && bda_check_capacity_c2j_call(s, "ToReflectedField")
    && bda_check_no_critical(s, "ToReflectedField")
    && bda_check_non_null(s, p1,  1, "ToReflectedField")
    && bda_check_non_null(s, p2,  2, "ToReflectedField")
    && bda_check_dref(s, p1, 1, "ToReflectedField")
    && bda_check_jclass(s, p1, 1, "ToReflectedField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ToReflectedField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ToReflectedField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID) %d(jboolean)\n", "ToReflectedField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ToReflectedField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ToReflectedField", s->name)) {
    printf("<= %-50s %p\n", "ToReflectedField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for Throw*/
static jint JNICALL bda_c2j_proxy_Throw(JNIEnv * env, jthrowable p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.Throw++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.Throw++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "Throw")
    && bda_check_no_exeception(s, "Throw")
    && bda_check_no_critical(s, "Throw")
    && bda_check_non_null(s, p1,  1, "Throw")
    && bda_check_dref(s, p1, 1, "Throw")
    && bda_check_jthrowable(s, p1, 1, "Throw")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_Throw;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("Throw", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jthrowable)\n", "Throw" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->Throw(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("Throw", s->name)) {
    printf("<= %-50s %d\n", "Throw", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for ThrowNew*/
static jint JNICALL bda_c2j_proxy_ThrowNew(JNIEnv * env, jclass p1, const char * p2)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ThrowNew++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ThrowNew++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ThrowNew")
    && bda_check_no_exeception(s, "ThrowNew")
    && bda_check_no_critical(s, "ThrowNew")
    && bda_check_non_null(s, p1,  1, "ThrowNew")
    && bda_check_non_null(s, p2,  2, "ThrowNew")
    && bda_check_dref(s, p1, 1, "ThrowNew")
    && bda_check_jclass(s, p1, 1, "ThrowNew")
    && bda_check_subclass_jclass_jclass(s, p1, bda_clazz_throwable, 1, "ThrowNew")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ThrowNew;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ThrowNew", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %s(const char *)\n", "ThrowNew" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ThrowNew(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ThrowNew", s->name)) {
    printf("<= %-50s %d\n", "ThrowNew", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for ExceptionOccurred*/
static jthrowable JNICALL bda_c2j_proxy_ExceptionOccurred(JNIEnv * env)
{
  /* local variables */
  jthrowable result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ExceptionOccurred++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ExceptionOccurred++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ExceptionOccurred")
    && bda_check_capacity_c2j_call(s, "ExceptionOccurred")
    && bda_check_no_critical(s, "ExceptionOccurred")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ExceptionOccurred;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ExceptionOccurred", s->name)) {
    printf("=> %-50s %p(JNIEnv *)\n", "ExceptionOccurred" , env);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ExceptionOccurred(env);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ExceptionOccurred", s->name)) {
    printf("<= %-50s %p\n", "ExceptionOccurred", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for ExceptionDescribe*/
static void JNICALL bda_c2j_proxy_ExceptionDescribe(JNIEnv * env)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ExceptionDescribe++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ExceptionDescribe++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ExceptionDescribe")
    && bda_check_no_critical(s, "ExceptionDescribe")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ExceptionDescribe;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ExceptionDescribe", s->name)) {
    printf("=> %-50s %p(JNIEnv *)\n", "ExceptionDescribe" , env);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ExceptionDescribe(env);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ExceptionDescribe", s->name)) {
    printf("<= %-50s\n", "ExceptionDescribe");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for ExceptionClear*/
static void JNICALL bda_c2j_proxy_ExceptionClear(JNIEnv * env)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ExceptionClear++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ExceptionClear++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ExceptionClear")
    && bda_check_no_critical(s, "ExceptionClear")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ExceptionClear;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ExceptionClear", s->name)) {
    printf("=> %-50s %p(JNIEnv *)\n", "ExceptionClear" , env);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ExceptionClear(env);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ExceptionClear", s->name)) {
    printf("<= %-50s\n", "ExceptionClear");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for FatalError*/
static void JNICALL bda_c2j_proxy_FatalError(JNIEnv * env, const char * p1)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.FatalError++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.FatalError++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "FatalError")
    && bda_check_no_exeception(s, "FatalError")
    && bda_check_no_critical(s, "FatalError")
    && bda_check_non_null(s, p1,  1, "FatalError")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_FatalError;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("FatalError", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %s(const char *)\n", "FatalError" , env, p1);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->FatalError(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("FatalError", s->name)) {
    printf("<= %-50s\n", "FatalError");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for PushLocalFrame*/
static jint JNICALL bda_c2j_proxy_PushLocalFrame(JNIEnv * env, jint p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.PushLocalFrame++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.PushLocalFrame++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "PushLocalFrame")
    && bda_check_no_exeception(s, "PushLocalFrame")
    && bda_check_no_critical(s, "PushLocalFrame")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_PushLocalFrame;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("PushLocalFrame", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %d(jint)\n", "PushLocalFrame" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->PushLocalFrame(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("PushLocalFrame", s->name)) {
    printf("<= %-50s %d\n", "PushLocalFrame", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
   if (result == 0) {
     bda_local_ref_enter(s, p1, 0);
   }
  }

  return result;
}


/* proxy for PopLocalFrame*/
static jobject JNICALL bda_c2j_proxy_PopLocalFrame(JNIEnv * env, jobject p1)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.PopLocalFrame++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.PopLocalFrame++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "PopLocalFrame")
    && bda_check_no_exeception(s, "PopLocalFrame")
    && bda_check_capacity_c2j_call(s, "PopLocalFrame")
    && bda_check_no_critical(s, "PopLocalFrame")
    && bda_check_dref(s, p1, 1, "PopLocalFrame")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_PopLocalFrame;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("PopLocalFrame", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "PopLocalFrame" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->PopLocalFrame(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("PopLocalFrame", s->name)) {
    printf("<= %-50s %p\n", "PopLocalFrame", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for NewGlobalRef*/
static jobject JNICALL bda_c2j_proxy_NewGlobalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewGlobalRef++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewGlobalRef++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewGlobalRef")
    && bda_check_no_exeception(s, "NewGlobalRef")
    && bda_check_capacity_c2j_call(s, "NewGlobalRef")
    && bda_check_no_critical(s, "NewGlobalRef")
    && bda_check_non_null(s, p1,  1, "NewGlobalRef")
    && bda_check_dref(s, p1, 1, "NewGlobalRef")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewGlobalRef;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewGlobalRef", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "NewGlobalRef" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewGlobalRef(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewGlobalRef", s->name)) {
    printf("<= %-50s %p\n", "NewGlobalRef", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      bda_global_ref_add(result, 0);
    }
  }

  return result;
}


/* proxy for DeleteGlobalRef*/
static void JNICALL bda_c2j_proxy_DeleteGlobalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.DeleteGlobalRef++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.DeleteGlobalRef++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "DeleteGlobalRef")
    && bda_check_no_critical(s, "DeleteGlobalRef")
    && bda_check_non_null(s, p1,  1, "DeleteGlobalRef")
    && bda_check_jobject_ref_type(s, p1, JNIGlobalRefType, 1, "DeleteGlobalRef")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_DeleteGlobalRef;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("DeleteGlobalRef", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "DeleteGlobalRef" , env, p1);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->DeleteGlobalRef(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("DeleteGlobalRef", s->name)) {
    printf("<= %-50s\n", "DeleteGlobalRef");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
   bda_global_ref_delete(p1, 0);
  }

}


/* proxy for DeleteLocalRef*/
static void JNICALL bda_c2j_proxy_DeleteLocalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.DeleteLocalRef++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.DeleteLocalRef++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "DeleteLocalRef")
    && bda_check_no_critical(s, "DeleteLocalRef")
    && bda_check_jobject_ref_type(s, p1, JNILocalRefType, 1, "DeleteLocalRef")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_DeleteLocalRef;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("DeleteLocalRef", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "DeleteLocalRef" , env, p1);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->DeleteLocalRef(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("DeleteLocalRef", s->name)) {
    printf("<= %-50s\n", "DeleteLocalRef");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
   if (p1 != NULL) {bda_local_ref_delete(s, p1);}
  }

}


/* proxy for IsSameObject*/
static jboolean JNICALL bda_c2j_proxy_IsSameObject(JNIEnv * env, jobject p1, jobject p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.IsSameObject++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.IsSameObject++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "IsSameObject")
    && bda_check_no_exeception(s, "IsSameObject")
    && bda_check_no_critical(s, "IsSameObject")
    && bda_check_dref(s, p1, 1, "IsSameObject")
    && bda_check_dref(s, p2, 2, "IsSameObject")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_IsSameObject;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("IsSameObject", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jobject)\n", "IsSameObject" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->IsSameObject(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("IsSameObject", s->name)) {
    printf("<= %-50s %d\n", "IsSameObject", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for NewLocalRef*/
static jobject JNICALL bda_c2j_proxy_NewLocalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewLocalRef++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewLocalRef++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewLocalRef")
    && bda_check_no_exeception(s, "NewLocalRef")
    && bda_check_capacity_c2j_call(s, "NewLocalRef")
    && bda_check_no_critical(s, "NewLocalRef")
    && bda_check_non_null(s, p1,  1, "NewLocalRef")
    && bda_check_dref(s, p1, 1, "NewLocalRef")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewLocalRef;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewLocalRef", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "NewLocalRef" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewLocalRef(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewLocalRef", s->name)) {
    printf("<= %-50s %p\n", "NewLocalRef", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for EnsureLocalCapacity*/
static jint JNICALL bda_c2j_proxy_EnsureLocalCapacity(JNIEnv * env, jint p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.EnsureLocalCapacity++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.EnsureLocalCapacity++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "EnsureLocalCapacity")
    && bda_check_no_exeception(s, "EnsureLocalCapacity")
    && bda_check_no_critical(s, "EnsureLocalCapacity")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_EnsureLocalCapacity;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("EnsureLocalCapacity", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %d(jint)\n", "EnsureLocalCapacity" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->EnsureLocalCapacity(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("EnsureLocalCapacity", s->name)) {
    printf("<= %-50s %d\n", "EnsureLocalCapacity", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for AllocObject*/
static jobject JNICALL bda_c2j_proxy_AllocObject(JNIEnv * env, jclass p1)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.AllocObject++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.AllocObject++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "AllocObject")
    && bda_check_no_exeception(s, "AllocObject")
    && bda_check_capacity_c2j_call(s, "AllocObject")
    && bda_check_no_critical(s, "AllocObject")
    && bda_check_non_null(s, p1,  1, "AllocObject")
    && bda_check_dref(s, p1, 1, "AllocObject")
    && bda_check_jclass(s, p1, 1, "AllocObject")
    && bda_check_jclass_scalar_allocatable(s, p1, 1, "AllocObject")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_AllocObject;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("AllocObject", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass)\n", "AllocObject" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->AllocObject(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("AllocObject", s->name)) {
    printf("<= %-50s %p\n", "AllocObject", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for NewObject*/
static jobject JNICALL bda_c2j_proxy_NewObject(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewObject++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewObject++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "NewObject")
    && bda_check_no_exeception(s, "NewObject")
    && bda_check_capacity_c2j_call(s, "NewObject")
    && bda_check_no_critical(s, "NewObject")
    && bda_check_non_null(s, p1,  1, "NewObject")
    && bda_check_non_null(s, p2,  2, "NewObject")
    && bda_check_dref(s, p1, 1, "NewObject")
    && bda_check_jclass(s, p1, 1, "NewObject")
    && bda_check_jmethodid_new_object(s, p1, p2, awrap, "NewObject")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewObject;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewObject", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID)\n", "NewObject" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->NewObjectV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewObject", s->name)) {
    printf("<= %-50s %p\n", "NewObject", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for NewObjectV*/
static jobject JNICALL bda_c2j_proxy_NewObjectV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewObjectV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewObjectV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
    awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "NewObjectV")
    && bda_check_no_exeception(s, "NewObjectV")
    && bda_check_capacity_c2j_call(s, "NewObjectV")
    && bda_check_no_critical(s, "NewObjectV")
    && bda_check_non_null(s, p1,  1, "NewObjectV")
    && bda_check_non_null(s, p2,  2, "NewObjectV")
    && bda_check_dref(s, p1, 1, "NewObjectV")
    && bda_check_jclass(s, p1, 1, "NewObjectV")
    && bda_check_jmethodid_new_object(s, p1, p2, awrap, "NewObjectV")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewObjectV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewObjectV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(va_list)\n", "NewObjectV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewObjectV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewObjectV", s->name)) {
    printf("<= %-50s %p\n", "NewObjectV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for NewObjectA*/
static jobject JNICALL bda_c2j_proxy_NewObjectA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewObjectA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewObjectA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "NewObjectA")
    && bda_check_no_exeception(s, "NewObjectA")
    && bda_check_capacity_c2j_call(s, "NewObjectA")
    && bda_check_no_critical(s, "NewObjectA")
    && bda_check_non_null(s, p1,  1, "NewObjectA")
    && bda_check_non_null(s, p2,  2, "NewObjectA")
    && bda_check_dref(s, p1, 1, "NewObjectA")
    && bda_check_jclass(s, p1, 1, "NewObjectA")
    && bda_check_jmethodid_new_object(s, p1, p2, awrap, "NewObjectA")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewObjectA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewObjectA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "NewObjectA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewObjectA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewObjectA", s->name)) {
    printf("<= %-50s %p\n", "NewObjectA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for GetObjectClass*/
static jclass JNICALL bda_c2j_proxy_GetObjectClass(JNIEnv * env, jobject p1)
{
  /* local variables */
  jclass result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetObjectClass++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetObjectClass++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetObjectClass")
    && bda_check_no_exeception(s, "GetObjectClass")
    && bda_check_capacity_c2j_call(s, "GetObjectClass")
    && bda_check_no_critical(s, "GetObjectClass")
    && bda_check_non_null(s, p1,  1, "GetObjectClass")
    && bda_check_dref(s, p1, 1, "GetObjectClass")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetObjectClass;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetObjectClass", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "GetObjectClass" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetObjectClass(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetObjectClass", s->name)) {
    printf("<= %-50s %p\n", "GetObjectClass", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for IsInstanceOf*/
static jboolean JNICALL bda_c2j_proxy_IsInstanceOf(JNIEnv * env, jobject p1, jclass p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.IsInstanceOf++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.IsInstanceOf++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "IsInstanceOf")
    && bda_check_no_exeception(s, "IsInstanceOf")
    && bda_check_no_critical(s, "IsInstanceOf")
    && bda_check_non_null(s, p1,  1, "IsInstanceOf")
    && bda_check_non_null(s, p2,  2, "IsInstanceOf")
    && bda_check_dref(s, p1, 1, "IsInstanceOf")
    && bda_check_dref(s, p2, 2, "IsInstanceOf")
    && bda_check_jclass(s, p2, 2, "IsInstanceOf")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_IsInstanceOf;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("IsInstanceOf", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass)\n", "IsInstanceOf" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->IsInstanceOf(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("IsInstanceOf", s->name)) {
    printf("<= %-50s %d\n", "IsInstanceOf", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetMethodID*/
static jmethodID JNICALL bda_c2j_proxy_GetMethodID(JNIEnv * env, jclass p1, const char * p2, const char * p3)
{
  /* local variables */
  jmethodID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetMethodID++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetMethodID++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetMethodID")
    && bda_check_no_exeception(s, "GetMethodID")
    && bda_check_no_critical(s, "GetMethodID")
    && bda_check_non_null(s, p1,  1, "GetMethodID")
    && bda_check_non_null(s, p2,  2, "GetMethodID")
    && bda_check_non_null(s, p3,  3, "GetMethodID")
    && bda_check_dref(s, p1, 1, "GetMethodID")
    && bda_check_jclass(s, p1, 1, "GetMethodID")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetMethodID;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetMethodID", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %s(const char *) %s(const char *)\n", "GetMethodID" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetMethodID(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetMethodID", s->name)) {
    printf("<= %-50s %p\n", "GetMethodID", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
   if (result != NULL) {
       bda_jmethodid_append( result, 0, p1, p2, p3);
   }
  }

  return result;
}


/* proxy for CallObjectMethod*/
static jobject JNICALL bda_c2j_proxy_CallObjectMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallObjectMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallObjectMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallObjectMethod")
    && bda_check_no_exeception(s, "CallObjectMethod")
    && bda_check_capacity_c2j_call(s, "CallObjectMethod")
    && bda_check_no_critical(s, "CallObjectMethod")
    && bda_check_non_null(s, p1,  1, "CallObjectMethod")
    && bda_check_non_null(s, p2,  2, "CallObjectMethod")
    && bda_check_dref(s, p1, 1, "CallObjectMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallObjectMethod", 'O')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallObjectMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallObjectMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID)\n", "CallObjectMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallObjectMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallObjectMethod", s->name)) {
    printf("<= %-50s %p\n", "CallObjectMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for CallObjectMethodV*/
static jobject JNICALL bda_c2j_proxy_CallObjectMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallObjectMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallObjectMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallObjectMethodV")
    && bda_check_no_exeception(s, "CallObjectMethodV")
    && bda_check_capacity_c2j_call(s, "CallObjectMethodV")
    && bda_check_no_critical(s, "CallObjectMethodV")
    && bda_check_non_null(s, p1,  1, "CallObjectMethodV")
    && bda_check_non_null(s, p2,  2, "CallObjectMethodV")
    && bda_check_dref(s, p1, 1, "CallObjectMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallObjectMethodV", 'O')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallObjectMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallObjectMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(va_list)\n", "CallObjectMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallObjectMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallObjectMethodV", s->name)) {
    printf("<= %-50s %p\n", "CallObjectMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for CallObjectMethodA*/
static jobject JNICALL bda_c2j_proxy_CallObjectMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallObjectMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallObjectMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallObjectMethodA")
    && bda_check_no_exeception(s, "CallObjectMethodA")
    && bda_check_capacity_c2j_call(s, "CallObjectMethodA")
    && bda_check_no_critical(s, "CallObjectMethodA")
    && bda_check_non_null(s, p1,  1, "CallObjectMethodA")
    && bda_check_non_null(s, p2,  2, "CallObjectMethodA")
    && bda_check_dref(s, p1, 1, "CallObjectMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallObjectMethodA", 'O')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallObjectMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallObjectMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(const jvalue *)\n", "CallObjectMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallObjectMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallObjectMethodA", s->name)) {
    printf("<= %-50s %p\n", "CallObjectMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for CallBooleanMethod*/
static jboolean JNICALL bda_c2j_proxy_CallBooleanMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallBooleanMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallBooleanMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallBooleanMethod")
    && bda_check_no_exeception(s, "CallBooleanMethod")
    && bda_check_no_critical(s, "CallBooleanMethod")
    && bda_check_non_null(s, p1,  1, "CallBooleanMethod")
    && bda_check_non_null(s, p2,  2, "CallBooleanMethod")
    && bda_check_dref(s, p1, 1, "CallBooleanMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallBooleanMethod", 'Z')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallBooleanMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallBooleanMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID)\n", "CallBooleanMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallBooleanMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallBooleanMethod", s->name)) {
    printf("<= %-50s %d\n", "CallBooleanMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallBooleanMethodV*/
static jboolean JNICALL bda_c2j_proxy_CallBooleanMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallBooleanMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallBooleanMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallBooleanMethodV")
    && bda_check_no_exeception(s, "CallBooleanMethodV")
    && bda_check_no_critical(s, "CallBooleanMethodV")
    && bda_check_non_null(s, p1,  1, "CallBooleanMethodV")
    && bda_check_non_null(s, p2,  2, "CallBooleanMethodV")
    && bda_check_dref(s, p1, 1, "CallBooleanMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallBooleanMethodV", 'Z')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallBooleanMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallBooleanMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(va_list)\n", "CallBooleanMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallBooleanMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallBooleanMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallBooleanMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallBooleanMethodA*/
static jboolean JNICALL bda_c2j_proxy_CallBooleanMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallBooleanMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallBooleanMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallBooleanMethodA")
    && bda_check_no_exeception(s, "CallBooleanMethodA")
    && bda_check_no_critical(s, "CallBooleanMethodA")
    && bda_check_non_null(s, p1,  1, "CallBooleanMethodA")
    && bda_check_non_null(s, p2,  2, "CallBooleanMethodA")
    && bda_check_dref(s, p1, 1, "CallBooleanMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallBooleanMethodA", 'Z')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallBooleanMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallBooleanMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(const jvalue *)\n", "CallBooleanMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallBooleanMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallBooleanMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallBooleanMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallByteMethod*/
static jbyte JNICALL bda_c2j_proxy_CallByteMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallByteMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallByteMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallByteMethod")
    && bda_check_no_exeception(s, "CallByteMethod")
    && bda_check_no_critical(s, "CallByteMethod")
    && bda_check_non_null(s, p1,  1, "CallByteMethod")
    && bda_check_non_null(s, p2,  2, "CallByteMethod")
    && bda_check_dref(s, p1, 1, "CallByteMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallByteMethod", 'B')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallByteMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallByteMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID)\n", "CallByteMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallByteMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallByteMethod", s->name)) {
    printf("<= %-50s %d\n", "CallByteMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallByteMethodV*/
static jbyte JNICALL bda_c2j_proxy_CallByteMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallByteMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallByteMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallByteMethodV")
    && bda_check_no_exeception(s, "CallByteMethodV")
    && bda_check_no_critical(s, "CallByteMethodV")
    && bda_check_non_null(s, p1,  1, "CallByteMethodV")
    && bda_check_non_null(s, p2,  2, "CallByteMethodV")
    && bda_check_dref(s, p1, 1, "CallByteMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallByteMethodV", 'B')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallByteMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallByteMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(va_list)\n", "CallByteMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallByteMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallByteMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallByteMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallByteMethodA*/
static jbyte JNICALL bda_c2j_proxy_CallByteMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallByteMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallByteMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallByteMethodA")
    && bda_check_no_exeception(s, "CallByteMethodA")
    && bda_check_no_critical(s, "CallByteMethodA")
    && bda_check_non_null(s, p1,  1, "CallByteMethodA")
    && bda_check_non_null(s, p2,  2, "CallByteMethodA")
    && bda_check_dref(s, p1, 1, "CallByteMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallByteMethodA", 'B')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallByteMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallByteMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(const jvalue *)\n", "CallByteMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallByteMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallByteMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallByteMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallCharMethod*/
static jchar JNICALL bda_c2j_proxy_CallCharMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallCharMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallCharMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallCharMethod")
    && bda_check_no_exeception(s, "CallCharMethod")
    && bda_check_no_critical(s, "CallCharMethod")
    && bda_check_non_null(s, p1,  1, "CallCharMethod")
    && bda_check_non_null(s, p2,  2, "CallCharMethod")
    && bda_check_dref(s, p1, 1, "CallCharMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallCharMethod", 'C')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallCharMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallCharMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID)\n", "CallCharMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallCharMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallCharMethod", s->name)) {
    printf("<= %-50s %d\n", "CallCharMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallCharMethodV*/
static jchar JNICALL bda_c2j_proxy_CallCharMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallCharMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallCharMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallCharMethodV")
    && bda_check_no_exeception(s, "CallCharMethodV")
    && bda_check_no_critical(s, "CallCharMethodV")
    && bda_check_non_null(s, p1,  1, "CallCharMethodV")
    && bda_check_non_null(s, p2,  2, "CallCharMethodV")
    && bda_check_dref(s, p1, 1, "CallCharMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallCharMethodV", 'C')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallCharMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallCharMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(va_list)\n", "CallCharMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallCharMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallCharMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallCharMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallCharMethodA*/
static jchar JNICALL bda_c2j_proxy_CallCharMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallCharMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallCharMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallCharMethodA")
    && bda_check_no_exeception(s, "CallCharMethodA")
    && bda_check_no_critical(s, "CallCharMethodA")
    && bda_check_non_null(s, p1,  1, "CallCharMethodA")
    && bda_check_non_null(s, p2,  2, "CallCharMethodA")
    && bda_check_dref(s, p1, 1, "CallCharMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallCharMethodA", 'C')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallCharMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallCharMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(const jvalue *)\n", "CallCharMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallCharMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallCharMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallCharMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallShortMethod*/
static jshort JNICALL bda_c2j_proxy_CallShortMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallShortMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallShortMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallShortMethod")
    && bda_check_no_exeception(s, "CallShortMethod")
    && bda_check_no_critical(s, "CallShortMethod")
    && bda_check_non_null(s, p1,  1, "CallShortMethod")
    && bda_check_non_null(s, p2,  2, "CallShortMethod")
    && bda_check_dref(s, p1, 1, "CallShortMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallShortMethod", 'S')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallShortMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallShortMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID)\n", "CallShortMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallShortMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallShortMethod", s->name)) {
    printf("<= %-50s %d\n", "CallShortMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallShortMethodV*/
static jshort JNICALL bda_c2j_proxy_CallShortMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallShortMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallShortMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallShortMethodV")
    && bda_check_no_exeception(s, "CallShortMethodV")
    && bda_check_no_critical(s, "CallShortMethodV")
    && bda_check_non_null(s, p1,  1, "CallShortMethodV")
    && bda_check_non_null(s, p2,  2, "CallShortMethodV")
    && bda_check_dref(s, p1, 1, "CallShortMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallShortMethodV", 'S')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallShortMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallShortMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(va_list)\n", "CallShortMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallShortMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallShortMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallShortMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallShortMethodA*/
static jshort JNICALL bda_c2j_proxy_CallShortMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallShortMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallShortMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallShortMethodA")
    && bda_check_no_exeception(s, "CallShortMethodA")
    && bda_check_no_critical(s, "CallShortMethodA")
    && bda_check_non_null(s, p1,  1, "CallShortMethodA")
    && bda_check_non_null(s, p2,  2, "CallShortMethodA")
    && bda_check_dref(s, p1, 1, "CallShortMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallShortMethodA", 'S')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallShortMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallShortMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(const jvalue *)\n", "CallShortMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallShortMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallShortMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallShortMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallIntMethod*/
static jint JNICALL bda_c2j_proxy_CallIntMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallIntMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallIntMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallIntMethod")
    && bda_check_no_exeception(s, "CallIntMethod")
    && bda_check_no_critical(s, "CallIntMethod")
    && bda_check_non_null(s, p1,  1, "CallIntMethod")
    && bda_check_non_null(s, p2,  2, "CallIntMethod")
    && bda_check_dref(s, p1, 1, "CallIntMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallIntMethod", 'I')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallIntMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallIntMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID)\n", "CallIntMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallIntMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallIntMethod", s->name)) {
    printf("<= %-50s %d\n", "CallIntMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallIntMethodV*/
static jint JNICALL bda_c2j_proxy_CallIntMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallIntMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallIntMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallIntMethodV")
    && bda_check_no_exeception(s, "CallIntMethodV")
    && bda_check_no_critical(s, "CallIntMethodV")
    && bda_check_non_null(s, p1,  1, "CallIntMethodV")
    && bda_check_non_null(s, p2,  2, "CallIntMethodV")
    && bda_check_dref(s, p1, 1, "CallIntMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallIntMethodV", 'I')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallIntMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallIntMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(va_list)\n", "CallIntMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallIntMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallIntMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallIntMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallIntMethodA*/
static jint JNICALL bda_c2j_proxy_CallIntMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallIntMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallIntMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallIntMethodA")
    && bda_check_no_exeception(s, "CallIntMethodA")
    && bda_check_no_critical(s, "CallIntMethodA")
    && bda_check_non_null(s, p1,  1, "CallIntMethodA")
    && bda_check_non_null(s, p2,  2, "CallIntMethodA")
    && bda_check_dref(s, p1, 1, "CallIntMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallIntMethodA", 'I')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallIntMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallIntMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(const jvalue *)\n", "CallIntMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallIntMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallIntMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallIntMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallLongMethod*/
static jlong JNICALL bda_c2j_proxy_CallLongMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallLongMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallLongMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallLongMethod")
    && bda_check_no_exeception(s, "CallLongMethod")
    && bda_check_no_critical(s, "CallLongMethod")
    && bda_check_non_null(s, p1,  1, "CallLongMethod")
    && bda_check_non_null(s, p2,  2, "CallLongMethod")
    && bda_check_dref(s, p1, 1, "CallLongMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallLongMethod", 'J')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallLongMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallLongMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID)\n", "CallLongMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallLongMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallLongMethod", s->name)) {
    printf("<= %-50s %lld\n", "CallLongMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallLongMethodV*/
static jlong JNICALL bda_c2j_proxy_CallLongMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallLongMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallLongMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallLongMethodV")
    && bda_check_no_exeception(s, "CallLongMethodV")
    && bda_check_no_critical(s, "CallLongMethodV")
    && bda_check_non_null(s, p1,  1, "CallLongMethodV")
    && bda_check_non_null(s, p2,  2, "CallLongMethodV")
    && bda_check_dref(s, p1, 1, "CallLongMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallLongMethodV", 'J')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallLongMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallLongMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(va_list)\n", "CallLongMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallLongMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallLongMethodV", s->name)) {
    printf("<= %-50s %lld\n", "CallLongMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallLongMethodA*/
static jlong JNICALL bda_c2j_proxy_CallLongMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallLongMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallLongMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallLongMethodA")
    && bda_check_no_exeception(s, "CallLongMethodA")
    && bda_check_no_critical(s, "CallLongMethodA")
    && bda_check_non_null(s, p1,  1, "CallLongMethodA")
    && bda_check_non_null(s, p2,  2, "CallLongMethodA")
    && bda_check_dref(s, p1, 1, "CallLongMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallLongMethodA", 'J')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallLongMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallLongMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(const jvalue *)\n", "CallLongMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallLongMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallLongMethodA", s->name)) {
    printf("<= %-50s %lld\n", "CallLongMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallFloatMethod*/
static jfloat JNICALL bda_c2j_proxy_CallFloatMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallFloatMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallFloatMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallFloatMethod")
    && bda_check_no_exeception(s, "CallFloatMethod")
    && bda_check_no_critical(s, "CallFloatMethod")
    && bda_check_non_null(s, p1,  1, "CallFloatMethod")
    && bda_check_non_null(s, p2,  2, "CallFloatMethod")
    && bda_check_dref(s, p1, 1, "CallFloatMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallFloatMethod", 'F')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallFloatMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallFloatMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID)\n", "CallFloatMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallFloatMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallFloatMethod", s->name)) {
    printf("<= %-50s %f\n", "CallFloatMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallFloatMethodV*/
static jfloat JNICALL bda_c2j_proxy_CallFloatMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallFloatMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallFloatMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallFloatMethodV")
    && bda_check_no_exeception(s, "CallFloatMethodV")
    && bda_check_no_critical(s, "CallFloatMethodV")
    && bda_check_non_null(s, p1,  1, "CallFloatMethodV")
    && bda_check_non_null(s, p2,  2, "CallFloatMethodV")
    && bda_check_dref(s, p1, 1, "CallFloatMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallFloatMethodV", 'F')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallFloatMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallFloatMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(va_list)\n", "CallFloatMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallFloatMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallFloatMethodV", s->name)) {
    printf("<= %-50s %f\n", "CallFloatMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallFloatMethodA*/
static jfloat JNICALL bda_c2j_proxy_CallFloatMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallFloatMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallFloatMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallFloatMethodA")
    && bda_check_no_exeception(s, "CallFloatMethodA")
    && bda_check_no_critical(s, "CallFloatMethodA")
    && bda_check_non_null(s, p1,  1, "CallFloatMethodA")
    && bda_check_non_null(s, p2,  2, "CallFloatMethodA")
    && bda_check_dref(s, p1, 1, "CallFloatMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallFloatMethodA", 'F')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallFloatMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallFloatMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(const jvalue *)\n", "CallFloatMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallFloatMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallFloatMethodA", s->name)) {
    printf("<= %-50s %f\n", "CallFloatMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallDoubleMethod*/
static jdouble JNICALL bda_c2j_proxy_CallDoubleMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallDoubleMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallDoubleMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallDoubleMethod")
    && bda_check_no_exeception(s, "CallDoubleMethod")
    && bda_check_no_critical(s, "CallDoubleMethod")
    && bda_check_non_null(s, p1,  1, "CallDoubleMethod")
    && bda_check_non_null(s, p2,  2, "CallDoubleMethod")
    && bda_check_dref(s, p1, 1, "CallDoubleMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallDoubleMethod", 'D')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallDoubleMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallDoubleMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID)\n", "CallDoubleMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallDoubleMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallDoubleMethod", s->name)) {
    printf("<= %-50s %lf\n", "CallDoubleMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallDoubleMethodV*/
static jdouble JNICALL bda_c2j_proxy_CallDoubleMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallDoubleMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallDoubleMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallDoubleMethodV")
    && bda_check_no_exeception(s, "CallDoubleMethodV")
    && bda_check_no_critical(s, "CallDoubleMethodV")
    && bda_check_non_null(s, p1,  1, "CallDoubleMethodV")
    && bda_check_non_null(s, p2,  2, "CallDoubleMethodV")
    && bda_check_dref(s, p1, 1, "CallDoubleMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallDoubleMethodV", 'D')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallDoubleMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallDoubleMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(va_list)\n", "CallDoubleMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallDoubleMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallDoubleMethodV", s->name)) {
    printf("<= %-50s %lf\n", "CallDoubleMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallDoubleMethodA*/
static jdouble JNICALL bda_c2j_proxy_CallDoubleMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallDoubleMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallDoubleMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallDoubleMethodA")
    && bda_check_no_exeception(s, "CallDoubleMethodA")
    && bda_check_no_critical(s, "CallDoubleMethodA")
    && bda_check_non_null(s, p1,  1, "CallDoubleMethodA")
    && bda_check_non_null(s, p2,  2, "CallDoubleMethodA")
    && bda_check_dref(s, p1, 1, "CallDoubleMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallDoubleMethodA", 'D')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallDoubleMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallDoubleMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(const jvalue *)\n", "CallDoubleMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallDoubleMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallDoubleMethodA", s->name)) {
    printf("<= %-50s %lf\n", "CallDoubleMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallVoidMethod*/
static void JNICALL bda_c2j_proxy_CallVoidMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallVoidMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallVoidMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallVoidMethod")
    && bda_check_no_exeception(s, "CallVoidMethod")
    && bda_check_no_critical(s, "CallVoidMethod")
    && bda_check_non_null(s, p1,  1, "CallVoidMethod")
    && bda_check_non_null(s, p2,  2, "CallVoidMethod")
    && bda_check_dref(s, p1, 1, "CallVoidMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallVoidMethod", 'V')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallVoidMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallVoidMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID)\n", "CallVoidMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  bda_orig_jni_funcs->CallVoidMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallVoidMethod", s->name)) {
    printf("<= %-50s\n", "CallVoidMethod");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for CallVoidMethodV*/
static void JNICALL bda_c2j_proxy_CallVoidMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallVoidMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallVoidMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallVoidMethodV")
    && bda_check_no_exeception(s, "CallVoidMethodV")
    && bda_check_no_critical(s, "CallVoidMethodV")
    && bda_check_non_null(s, p1,  1, "CallVoidMethodV")
    && bda_check_non_null(s, p2,  2, "CallVoidMethodV")
    && bda_check_dref(s, p1, 1, "CallVoidMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallVoidMethodV", 'V')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallVoidMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallVoidMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(va_list)\n", "CallVoidMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallVoidMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallVoidMethodV", s->name)) {
    printf("<= %-50s\n", "CallVoidMethodV");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for CallVoidMethodA*/
static void JNICALL bda_c2j_proxy_CallVoidMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallVoidMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallVoidMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallVoidMethodA")
    && bda_check_no_exeception(s, "CallVoidMethodA")
    && bda_check_no_critical(s, "CallVoidMethodA")
    && bda_check_non_null(s, p1,  1, "CallVoidMethodA")
    && bda_check_non_null(s, p2,  2, "CallVoidMethodA")
    && bda_check_dref(s, p1, 1, "CallVoidMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallVoidMethodA", 'V')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallVoidMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallVoidMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jmethodID) %p(const jvalue *)\n", "CallVoidMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallVoidMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallVoidMethodA", s->name)) {
    printf("<= %-50s\n", "CallVoidMethodA");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for CallNonvirtualObjectMethod*/
static jobject JNICALL bda_c2j_proxy_CallNonvirtualObjectMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualObjectMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualObjectMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualObjectMethod")
    && bda_check_no_exeception(s, "CallNonvirtualObjectMethod")
    && bda_check_capacity_c2j_call(s, "CallNonvirtualObjectMethod")
    && bda_check_no_critical(s, "CallNonvirtualObjectMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualObjectMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualObjectMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualObjectMethod")
    && bda_check_dref(s, p1, 1, "CallNonvirtualObjectMethod")
    && bda_check_dref(s, p2, 2, "CallNonvirtualObjectMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualObjectMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualObjectMethod", 'O')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualObjectMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualObjectMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID)\n", "CallNonvirtualObjectMethod" , env, p1, p2, p3);
    va_start(args,p3);
    bda_jmethod_print_argument_from_va_list(env, p3, args);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualObjectMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualObjectMethod", s->name)) {
    printf("<= %-50s %p\n", "CallNonvirtualObjectMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for CallNonvirtualObjectMethodV*/
static jobject JNICALL bda_c2j_proxy_CallNonvirtualObjectMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualObjectMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualObjectMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualObjectMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualObjectMethodV")
    && bda_check_capacity_c2j_call(s, "CallNonvirtualObjectMethodV")
    && bda_check_no_critical(s, "CallNonvirtualObjectMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualObjectMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualObjectMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualObjectMethodV")
    && bda_check_dref(s, p1, 1, "CallNonvirtualObjectMethodV")
    && bda_check_dref(s, p2, 2, "CallNonvirtualObjectMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualObjectMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualObjectMethodV", 'O')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualObjectMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualObjectMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallNonvirtualObjectMethodV" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_va_list(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualObjectMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualObjectMethodV", s->name)) {
    printf("<= %-50s %p\n", "CallNonvirtualObjectMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for CallNonvirtualObjectMethodA*/
static jobject JNICALL bda_c2j_proxy_CallNonvirtualObjectMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualObjectMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualObjectMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualObjectMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualObjectMethodA")
    && bda_check_capacity_c2j_call(s, "CallNonvirtualObjectMethodA")
    && bda_check_no_critical(s, "CallNonvirtualObjectMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualObjectMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualObjectMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualObjectMethodA")
    && bda_check_dref(s, p1, 1, "CallNonvirtualObjectMethodA")
    && bda_check_dref(s, p2, 2, "CallNonvirtualObjectMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualObjectMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualObjectMethodA", 'O')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualObjectMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualObjectMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallNonvirtualObjectMethodA" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_array(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualObjectMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualObjectMethodA", s->name)) {
    printf("<= %-50s %p\n", "CallNonvirtualObjectMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for CallNonvirtualBooleanMethod*/
static jboolean JNICALL bda_c2j_proxy_CallNonvirtualBooleanMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualBooleanMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualBooleanMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualBooleanMethod")
    && bda_check_no_exeception(s, "CallNonvirtualBooleanMethod")
    && bda_check_no_critical(s, "CallNonvirtualBooleanMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualBooleanMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualBooleanMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualBooleanMethod")
    && bda_check_dref(s, p1, 1, "CallNonvirtualBooleanMethod")
    && bda_check_dref(s, p2, 2, "CallNonvirtualBooleanMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualBooleanMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualBooleanMethod", 'Z')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualBooleanMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualBooleanMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID)\n", "CallNonvirtualBooleanMethod" , env, p1, p2, p3);
    va_start(args,p3);
    bda_jmethod_print_argument_from_va_list(env, p3, args);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualBooleanMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualBooleanMethod", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualBooleanMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualBooleanMethodV*/
static jboolean JNICALL bda_c2j_proxy_CallNonvirtualBooleanMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualBooleanMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualBooleanMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualBooleanMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualBooleanMethodV")
    && bda_check_no_critical(s, "CallNonvirtualBooleanMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualBooleanMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualBooleanMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualBooleanMethodV")
    && bda_check_dref(s, p1, 1, "CallNonvirtualBooleanMethodV")
    && bda_check_dref(s, p2, 2, "CallNonvirtualBooleanMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualBooleanMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualBooleanMethodV", 'Z')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualBooleanMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualBooleanMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallNonvirtualBooleanMethodV" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_va_list(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualBooleanMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualBooleanMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualBooleanMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualBooleanMethodA*/
static jboolean JNICALL bda_c2j_proxy_CallNonvirtualBooleanMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualBooleanMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualBooleanMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualBooleanMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualBooleanMethodA")
    && bda_check_no_critical(s, "CallNonvirtualBooleanMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualBooleanMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualBooleanMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualBooleanMethodA")
    && bda_check_dref(s, p1, 1, "CallNonvirtualBooleanMethodA")
    && bda_check_dref(s, p2, 2, "CallNonvirtualBooleanMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualBooleanMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualBooleanMethodA", 'Z')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualBooleanMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualBooleanMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallNonvirtualBooleanMethodA" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_array(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualBooleanMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualBooleanMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualBooleanMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualByteMethod*/
static jbyte JNICALL bda_c2j_proxy_CallNonvirtualByteMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualByteMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualByteMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualByteMethod")
    && bda_check_no_exeception(s, "CallNonvirtualByteMethod")
    && bda_check_no_critical(s, "CallNonvirtualByteMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualByteMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualByteMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualByteMethod")
    && bda_check_dref(s, p1, 1, "CallNonvirtualByteMethod")
    && bda_check_dref(s, p2, 2, "CallNonvirtualByteMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualByteMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualByteMethod", 'B')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualByteMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualByteMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID)\n", "CallNonvirtualByteMethod" , env, p1, p2, p3);
    va_start(args,p3);
    bda_jmethod_print_argument_from_va_list(env, p3, args);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualByteMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualByteMethod", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualByteMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualByteMethodV*/
static jbyte JNICALL bda_c2j_proxy_CallNonvirtualByteMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualByteMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualByteMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualByteMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualByteMethodV")
    && bda_check_no_critical(s, "CallNonvirtualByteMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualByteMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualByteMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualByteMethodV")
    && bda_check_dref(s, p1, 1, "CallNonvirtualByteMethodV")
    && bda_check_dref(s, p2, 2, "CallNonvirtualByteMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualByteMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualByteMethodV", 'B')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualByteMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualByteMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallNonvirtualByteMethodV" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_va_list(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualByteMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualByteMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualByteMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualByteMethodA*/
static jbyte JNICALL bda_c2j_proxy_CallNonvirtualByteMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualByteMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualByteMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualByteMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualByteMethodA")
    && bda_check_no_critical(s, "CallNonvirtualByteMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualByteMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualByteMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualByteMethodA")
    && bda_check_dref(s, p1, 1, "CallNonvirtualByteMethodA")
    && bda_check_dref(s, p2, 2, "CallNonvirtualByteMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualByteMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualByteMethodA", 'B')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualByteMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualByteMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallNonvirtualByteMethodA" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_array(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualByteMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualByteMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualByteMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualCharMethod*/
static jchar JNICALL bda_c2j_proxy_CallNonvirtualCharMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualCharMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualCharMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualCharMethod")
    && bda_check_no_exeception(s, "CallNonvirtualCharMethod")
    && bda_check_no_critical(s, "CallNonvirtualCharMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualCharMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualCharMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualCharMethod")
    && bda_check_dref(s, p1, 1, "CallNonvirtualCharMethod")
    && bda_check_dref(s, p2, 2, "CallNonvirtualCharMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualCharMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualCharMethod", 'C')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualCharMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualCharMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID)\n", "CallNonvirtualCharMethod" , env, p1, p2, p3);
    va_start(args,p3);
    bda_jmethod_print_argument_from_va_list(env, p3, args);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualCharMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualCharMethod", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualCharMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualCharMethodV*/
static jchar JNICALL bda_c2j_proxy_CallNonvirtualCharMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualCharMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualCharMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualCharMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualCharMethodV")
    && bda_check_no_critical(s, "CallNonvirtualCharMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualCharMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualCharMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualCharMethodV")
    && bda_check_dref(s, p1, 1, "CallNonvirtualCharMethodV")
    && bda_check_dref(s, p2, 2, "CallNonvirtualCharMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualCharMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualCharMethodV", 'C')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualCharMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualCharMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallNonvirtualCharMethodV" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_va_list(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualCharMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualCharMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualCharMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualCharMethodA*/
static jchar JNICALL bda_c2j_proxy_CallNonvirtualCharMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualCharMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualCharMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualCharMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualCharMethodA")
    && bda_check_no_critical(s, "CallNonvirtualCharMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualCharMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualCharMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualCharMethodA")
    && bda_check_dref(s, p1, 1, "CallNonvirtualCharMethodA")
    && bda_check_dref(s, p2, 2, "CallNonvirtualCharMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualCharMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualCharMethodA", 'C')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualCharMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualCharMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallNonvirtualCharMethodA" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_array(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualCharMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualCharMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualCharMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualShortMethod*/
static jshort JNICALL bda_c2j_proxy_CallNonvirtualShortMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualShortMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualShortMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualShortMethod")
    && bda_check_no_exeception(s, "CallNonvirtualShortMethod")
    && bda_check_no_critical(s, "CallNonvirtualShortMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualShortMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualShortMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualShortMethod")
    && bda_check_dref(s, p1, 1, "CallNonvirtualShortMethod")
    && bda_check_dref(s, p2, 2, "CallNonvirtualShortMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualShortMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualShortMethod", 'S')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualShortMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualShortMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID)\n", "CallNonvirtualShortMethod" , env, p1, p2, p3);
    va_start(args,p3);
    bda_jmethod_print_argument_from_va_list(env, p3, args);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualShortMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualShortMethod", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualShortMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualShortMethodV*/
static jshort JNICALL bda_c2j_proxy_CallNonvirtualShortMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualShortMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualShortMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualShortMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualShortMethodV")
    && bda_check_no_critical(s, "CallNonvirtualShortMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualShortMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualShortMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualShortMethodV")
    && bda_check_dref(s, p1, 1, "CallNonvirtualShortMethodV")
    && bda_check_dref(s, p2, 2, "CallNonvirtualShortMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualShortMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualShortMethodV", 'S')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualShortMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualShortMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallNonvirtualShortMethodV" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_va_list(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualShortMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualShortMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualShortMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualShortMethodA*/
static jshort JNICALL bda_c2j_proxy_CallNonvirtualShortMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualShortMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualShortMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualShortMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualShortMethodA")
    && bda_check_no_critical(s, "CallNonvirtualShortMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualShortMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualShortMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualShortMethodA")
    && bda_check_dref(s, p1, 1, "CallNonvirtualShortMethodA")
    && bda_check_dref(s, p2, 2, "CallNonvirtualShortMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualShortMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualShortMethodA", 'S')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualShortMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualShortMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallNonvirtualShortMethodA" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_array(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualShortMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualShortMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualShortMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualIntMethod*/
static jint JNICALL bda_c2j_proxy_CallNonvirtualIntMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualIntMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualIntMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualIntMethod")
    && bda_check_no_exeception(s, "CallNonvirtualIntMethod")
    && bda_check_no_critical(s, "CallNonvirtualIntMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualIntMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualIntMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualIntMethod")
    && bda_check_dref(s, p1, 1, "CallNonvirtualIntMethod")
    && bda_check_dref(s, p2, 2, "CallNonvirtualIntMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualIntMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualIntMethod", 'I')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualIntMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualIntMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID)\n", "CallNonvirtualIntMethod" , env, p1, p2, p3);
    va_start(args,p3);
    bda_jmethod_print_argument_from_va_list(env, p3, args);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualIntMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualIntMethod", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualIntMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualIntMethodV*/
static jint JNICALL bda_c2j_proxy_CallNonvirtualIntMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualIntMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualIntMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualIntMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualIntMethodV")
    && bda_check_no_critical(s, "CallNonvirtualIntMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualIntMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualIntMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualIntMethodV")
    && bda_check_dref(s, p1, 1, "CallNonvirtualIntMethodV")
    && bda_check_dref(s, p2, 2, "CallNonvirtualIntMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualIntMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualIntMethodV", 'I')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualIntMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualIntMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallNonvirtualIntMethodV" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_va_list(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualIntMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualIntMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualIntMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualIntMethodA*/
static jint JNICALL bda_c2j_proxy_CallNonvirtualIntMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualIntMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualIntMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualIntMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualIntMethodA")
    && bda_check_no_critical(s, "CallNonvirtualIntMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualIntMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualIntMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualIntMethodA")
    && bda_check_dref(s, p1, 1, "CallNonvirtualIntMethodA")
    && bda_check_dref(s, p2, 2, "CallNonvirtualIntMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualIntMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualIntMethodA", 'I')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualIntMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualIntMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallNonvirtualIntMethodA" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_array(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualIntMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualIntMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallNonvirtualIntMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualLongMethod*/
static jlong JNICALL bda_c2j_proxy_CallNonvirtualLongMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualLongMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualLongMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualLongMethod")
    && bda_check_no_exeception(s, "CallNonvirtualLongMethod")
    && bda_check_no_critical(s, "CallNonvirtualLongMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualLongMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualLongMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualLongMethod")
    && bda_check_dref(s, p1, 1, "CallNonvirtualLongMethod")
    && bda_check_dref(s, p2, 2, "CallNonvirtualLongMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualLongMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualLongMethod", 'J')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualLongMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualLongMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID)\n", "CallNonvirtualLongMethod" , env, p1, p2, p3);
    va_start(args,p3);
    bda_jmethod_print_argument_from_va_list(env, p3, args);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualLongMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualLongMethod", s->name)) {
    printf("<= %-50s %lld\n", "CallNonvirtualLongMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualLongMethodV*/
static jlong JNICALL bda_c2j_proxy_CallNonvirtualLongMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualLongMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualLongMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualLongMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualLongMethodV")
    && bda_check_no_critical(s, "CallNonvirtualLongMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualLongMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualLongMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualLongMethodV")
    && bda_check_dref(s, p1, 1, "CallNonvirtualLongMethodV")
    && bda_check_dref(s, p2, 2, "CallNonvirtualLongMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualLongMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualLongMethodV", 'J')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualLongMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualLongMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallNonvirtualLongMethodV" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_va_list(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualLongMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualLongMethodV", s->name)) {
    printf("<= %-50s %lld\n", "CallNonvirtualLongMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualLongMethodA*/
static jlong JNICALL bda_c2j_proxy_CallNonvirtualLongMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualLongMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualLongMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualLongMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualLongMethodA")
    && bda_check_no_critical(s, "CallNonvirtualLongMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualLongMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualLongMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualLongMethodA")
    && bda_check_dref(s, p1, 1, "CallNonvirtualLongMethodA")
    && bda_check_dref(s, p2, 2, "CallNonvirtualLongMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualLongMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualLongMethodA", 'J')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualLongMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualLongMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallNonvirtualLongMethodA" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_array(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualLongMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualLongMethodA", s->name)) {
    printf("<= %-50s %lld\n", "CallNonvirtualLongMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualFloatMethod*/
static jfloat JNICALL bda_c2j_proxy_CallNonvirtualFloatMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualFloatMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualFloatMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualFloatMethod")
    && bda_check_no_exeception(s, "CallNonvirtualFloatMethod")
    && bda_check_no_critical(s, "CallNonvirtualFloatMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualFloatMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualFloatMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualFloatMethod")
    && bda_check_dref(s, p1, 1, "CallNonvirtualFloatMethod")
    && bda_check_dref(s, p2, 2, "CallNonvirtualFloatMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualFloatMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualFloatMethod", 'F')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualFloatMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualFloatMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID)\n", "CallNonvirtualFloatMethod" , env, p1, p2, p3);
    va_start(args,p3);
    bda_jmethod_print_argument_from_va_list(env, p3, args);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualFloatMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualFloatMethod", s->name)) {
    printf("<= %-50s %f\n", "CallNonvirtualFloatMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualFloatMethodV*/
static jfloat JNICALL bda_c2j_proxy_CallNonvirtualFloatMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualFloatMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualFloatMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualFloatMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualFloatMethodV")
    && bda_check_no_critical(s, "CallNonvirtualFloatMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualFloatMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualFloatMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualFloatMethodV")
    && bda_check_dref(s, p1, 1, "CallNonvirtualFloatMethodV")
    && bda_check_dref(s, p2, 2, "CallNonvirtualFloatMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualFloatMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualFloatMethodV", 'F')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualFloatMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualFloatMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallNonvirtualFloatMethodV" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_va_list(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualFloatMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualFloatMethodV", s->name)) {
    printf("<= %-50s %f\n", "CallNonvirtualFloatMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualFloatMethodA*/
static jfloat JNICALL bda_c2j_proxy_CallNonvirtualFloatMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualFloatMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualFloatMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualFloatMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualFloatMethodA")
    && bda_check_no_critical(s, "CallNonvirtualFloatMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualFloatMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualFloatMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualFloatMethodA")
    && bda_check_dref(s, p1, 1, "CallNonvirtualFloatMethodA")
    && bda_check_dref(s, p2, 2, "CallNonvirtualFloatMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualFloatMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualFloatMethodA", 'F')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualFloatMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualFloatMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallNonvirtualFloatMethodA" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_array(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualFloatMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualFloatMethodA", s->name)) {
    printf("<= %-50s %f\n", "CallNonvirtualFloatMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualDoubleMethod*/
static jdouble JNICALL bda_c2j_proxy_CallNonvirtualDoubleMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualDoubleMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualDoubleMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualDoubleMethod")
    && bda_check_no_exeception(s, "CallNonvirtualDoubleMethod")
    && bda_check_no_critical(s, "CallNonvirtualDoubleMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualDoubleMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualDoubleMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualDoubleMethod")
    && bda_check_dref(s, p1, 1, "CallNonvirtualDoubleMethod")
    && bda_check_dref(s, p2, 2, "CallNonvirtualDoubleMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualDoubleMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualDoubleMethod", 'D')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualDoubleMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualDoubleMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID)\n", "CallNonvirtualDoubleMethod" , env, p1, p2, p3);
    va_start(args,p3);
    bda_jmethod_print_argument_from_va_list(env, p3, args);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualDoubleMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualDoubleMethod", s->name)) {
    printf("<= %-50s %lf\n", "CallNonvirtualDoubleMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualDoubleMethodV*/
static jdouble JNICALL bda_c2j_proxy_CallNonvirtualDoubleMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualDoubleMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualDoubleMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualDoubleMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualDoubleMethodV")
    && bda_check_no_critical(s, "CallNonvirtualDoubleMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualDoubleMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualDoubleMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualDoubleMethodV")
    && bda_check_dref(s, p1, 1, "CallNonvirtualDoubleMethodV")
    && bda_check_dref(s, p2, 2, "CallNonvirtualDoubleMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualDoubleMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualDoubleMethodV", 'D')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualDoubleMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualDoubleMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallNonvirtualDoubleMethodV" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_va_list(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualDoubleMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualDoubleMethodV", s->name)) {
    printf("<= %-50s %lf\n", "CallNonvirtualDoubleMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualDoubleMethodA*/
static jdouble JNICALL bda_c2j_proxy_CallNonvirtualDoubleMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualDoubleMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualDoubleMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualDoubleMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualDoubleMethodA")
    && bda_check_no_critical(s, "CallNonvirtualDoubleMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualDoubleMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualDoubleMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualDoubleMethodA")
    && bda_check_dref(s, p1, 1, "CallNonvirtualDoubleMethodA")
    && bda_check_dref(s, p2, 2, "CallNonvirtualDoubleMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualDoubleMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualDoubleMethodA", 'D')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualDoubleMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualDoubleMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallNonvirtualDoubleMethodA" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_array(env, p3, p4);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualDoubleMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualDoubleMethodA", s->name)) {
    printf("<= %-50s %lf\n", "CallNonvirtualDoubleMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualVoidMethod*/
static void JNICALL bda_c2j_proxy_CallNonvirtualVoidMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualVoidMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualVoidMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualVoidMethod")
    && bda_check_no_exeception(s, "CallNonvirtualVoidMethod")
    && bda_check_no_critical(s, "CallNonvirtualVoidMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualVoidMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualVoidMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualVoidMethod")
    && bda_check_dref(s, p1, 1, "CallNonvirtualVoidMethod")
    && bda_check_dref(s, p2, 2, "CallNonvirtualVoidMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualVoidMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualVoidMethod", 'V')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualVoidMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualVoidMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID)\n", "CallNonvirtualVoidMethod" , env, p1, p2, p3);
    va_start(args,p3);
    bda_jmethod_print_argument_from_va_list(env, p3, args);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  bda_orig_jni_funcs->CallNonvirtualVoidMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualVoidMethod", s->name)) {
    printf("<= %-50s\n", "CallNonvirtualVoidMethod");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for CallNonvirtualVoidMethodV*/
static void JNICALL bda_c2j_proxy_CallNonvirtualVoidMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualVoidMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualVoidMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualVoidMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualVoidMethodV")
    && bda_check_no_critical(s, "CallNonvirtualVoidMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualVoidMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualVoidMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualVoidMethodV")
    && bda_check_dref(s, p1, 1, "CallNonvirtualVoidMethodV")
    && bda_check_dref(s, p2, 2, "CallNonvirtualVoidMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualVoidMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualVoidMethodV", 'V')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualVoidMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualVoidMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallNonvirtualVoidMethodV" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_va_list(env, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallNonvirtualVoidMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualVoidMethodV", s->name)) {
    printf("<= %-50s\n", "CallNonvirtualVoidMethodV");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for CallNonvirtualVoidMethodA*/
static void JNICALL bda_c2j_proxy_CallNonvirtualVoidMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallNonvirtualVoidMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualVoidMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualVoidMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualVoidMethodA")
    && bda_check_no_critical(s, "CallNonvirtualVoidMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualVoidMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualVoidMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualVoidMethodA")
    && bda_check_dref(s, p1, 1, "CallNonvirtualVoidMethodA")
    && bda_check_dref(s, p2, 2, "CallNonvirtualVoidMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualVoidMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualVoidMethodA", 'V')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualVoidMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualVoidMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallNonvirtualVoidMethodA" , env, p1, p2, p3, p4);
    bda_jmethod_print_argument_from_array(env, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallNonvirtualVoidMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallNonvirtualVoidMethodA", s->name)) {
    printf("<= %-50s\n", "CallNonvirtualVoidMethodA");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for GetFieldID*/
static jfieldID JNICALL bda_c2j_proxy_GetFieldID(JNIEnv * env, jclass p1, const char * p2, const char * p3)
{
  /* local variables */
  jfieldID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetFieldID++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetFieldID++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetFieldID")
    && bda_check_no_exeception(s, "GetFieldID")
    && bda_check_no_critical(s, "GetFieldID")
    && bda_check_non_null(s, p1,  1, "GetFieldID")
    && bda_check_non_null(s, p2,  2, "GetFieldID")
    && bda_check_non_null(s, p3,  3, "GetFieldID")
    && bda_check_dref(s, p1, 1, "GetFieldID")
    && bda_check_jclass(s, p1, 1, "GetFieldID")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetFieldID;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetFieldID", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %s(const char *) %s(const char *)\n", "GetFieldID" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetFieldID(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetFieldID", s->name)) {
    printf("<= %-50s %p\n", "GetFieldID", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
   if (result != NULL) {
       bda_jfieldid_append(s, result, p1, 0, p2, p3);
   }
  }

  return result;
}


/* proxy for GetObjectField*/
static jobject JNICALL bda_c2j_proxy_GetObjectField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetObjectField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetObjectField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetObjectField")
    && bda_check_no_exeception(s, "GetObjectField")
    && bda_check_capacity_c2j_call(s, "GetObjectField")
    && bda_check_no_critical(s, "GetObjectField")
    && bda_check_non_null(s, p1,  1, "GetObjectField")
    && bda_check_non_null(s, p2,  2, "GetObjectField")
    && bda_check_dref(s, p1, 1, "GetObjectField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'O', "GetObjectField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetObjectField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetObjectField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID)\n", "GetObjectField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetObjectField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetObjectField", s->name)) {
    printf("<= %-50s %p\n", "GetObjectField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for GetBooleanField*/
static jboolean JNICALL bda_c2j_proxy_GetBooleanField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetBooleanField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetBooleanField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetBooleanField")
    && bda_check_no_exeception(s, "GetBooleanField")
    && bda_check_no_critical(s, "GetBooleanField")
    && bda_check_non_null(s, p1,  1, "GetBooleanField")
    && bda_check_non_null(s, p2,  2, "GetBooleanField")
    && bda_check_dref(s, p1, 1, "GetBooleanField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'Z', "GetBooleanField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetBooleanField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetBooleanField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID)\n", "GetBooleanField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetBooleanField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetBooleanField", s->name)) {
    printf("<= %-50s %d\n", "GetBooleanField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetByteField*/
static jbyte JNICALL bda_c2j_proxy_GetByteField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetByteField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetByteField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetByteField")
    && bda_check_no_exeception(s, "GetByteField")
    && bda_check_no_critical(s, "GetByteField")
    && bda_check_non_null(s, p1,  1, "GetByteField")
    && bda_check_non_null(s, p2,  2, "GetByteField")
    && bda_check_dref(s, p1, 1, "GetByteField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'B', "GetByteField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetByteField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetByteField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID)\n", "GetByteField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetByteField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetByteField", s->name)) {
    printf("<= %-50s %d\n", "GetByteField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetCharField*/
static jchar JNICALL bda_c2j_proxy_GetCharField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetCharField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetCharField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetCharField")
    && bda_check_no_exeception(s, "GetCharField")
    && bda_check_no_critical(s, "GetCharField")
    && bda_check_non_null(s, p1,  1, "GetCharField")
    && bda_check_non_null(s, p2,  2, "GetCharField")
    && bda_check_dref(s, p1, 1, "GetCharField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'C', "GetCharField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetCharField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetCharField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID)\n", "GetCharField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetCharField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetCharField", s->name)) {
    printf("<= %-50s %d\n", "GetCharField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetShortField*/
static jshort JNICALL bda_c2j_proxy_GetShortField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetShortField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetShortField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetShortField")
    && bda_check_no_exeception(s, "GetShortField")
    && bda_check_no_critical(s, "GetShortField")
    && bda_check_non_null(s, p1,  1, "GetShortField")
    && bda_check_non_null(s, p2,  2, "GetShortField")
    && bda_check_dref(s, p1, 1, "GetShortField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'S', "GetShortField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetShortField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetShortField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID)\n", "GetShortField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetShortField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetShortField", s->name)) {
    printf("<= %-50s %d\n", "GetShortField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetIntField*/
static jint JNICALL bda_c2j_proxy_GetIntField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetIntField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetIntField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetIntField")
    && bda_check_no_exeception(s, "GetIntField")
    && bda_check_no_critical(s, "GetIntField")
    && bda_check_non_null(s, p1,  1, "GetIntField")
    && bda_check_non_null(s, p2,  2, "GetIntField")
    && bda_check_dref(s, p1, 1, "GetIntField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'I', "GetIntField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetIntField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetIntField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID)\n", "GetIntField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetIntField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetIntField", s->name)) {
    printf("<= %-50s %d\n", "GetIntField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetLongField*/
static jlong JNICALL bda_c2j_proxy_GetLongField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetLongField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetLongField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetLongField")
    && bda_check_no_exeception(s, "GetLongField")
    && bda_check_no_critical(s, "GetLongField")
    && bda_check_non_null(s, p1,  1, "GetLongField")
    && bda_check_non_null(s, p2,  2, "GetLongField")
    && bda_check_dref(s, p1, 1, "GetLongField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'J', "GetLongField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetLongField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetLongField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID)\n", "GetLongField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetLongField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetLongField", s->name)) {
    printf("<= %-50s %lld\n", "GetLongField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetFloatField*/
static jfloat JNICALL bda_c2j_proxy_GetFloatField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetFloatField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetFloatField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetFloatField")
    && bda_check_no_exeception(s, "GetFloatField")
    && bda_check_no_critical(s, "GetFloatField")
    && bda_check_non_null(s, p1,  1, "GetFloatField")
    && bda_check_non_null(s, p2,  2, "GetFloatField")
    && bda_check_dref(s, p1, 1, "GetFloatField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'F', "GetFloatField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetFloatField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetFloatField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID)\n", "GetFloatField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetFloatField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetFloatField", s->name)) {
    printf("<= %-50s %f\n", "GetFloatField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetDoubleField*/
static jdouble JNICALL bda_c2j_proxy_GetDoubleField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetDoubleField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetDoubleField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDoubleField")
    && bda_check_no_exeception(s, "GetDoubleField")
    && bda_check_no_critical(s, "GetDoubleField")
    && bda_check_non_null(s, p1,  1, "GetDoubleField")
    && bda_check_non_null(s, p2,  2, "GetDoubleField")
    && bda_check_dref(s, p1, 1, "GetDoubleField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'D', "GetDoubleField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDoubleField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetDoubleField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID)\n", "GetDoubleField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetDoubleField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetDoubleField", s->name)) {
    printf("<= %-50s %lf\n", "GetDoubleField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for SetObjectField*/
static void JNICALL bda_c2j_proxy_SetObjectField(JNIEnv * env, jobject p1, jfieldID p2, jobject p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetObjectField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetObjectField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.l = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetObjectField")
    && bda_check_no_exeception(s, "SetObjectField")
    && bda_check_no_critical(s, "SetObjectField")
    && bda_check_non_null(s, p1,  1, "SetObjectField")
    && bda_check_non_null(s, p2,  2, "SetObjectField")
    && bda_check_dref(s, p1, 1, "SetObjectField")
    && bda_check_dref(s, p3, 3, "SetObjectField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetObjectField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'O', "SetObjectField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetObjectField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetObjectField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetObjectField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetObjectField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID) %p(jobject)\n", "SetObjectField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetObjectField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetObjectField", s->name)) {
    printf("<= %-50s\n", "SetObjectField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetBooleanField*/
static void JNICALL bda_c2j_proxy_SetBooleanField(JNIEnv * env, jobject p1, jfieldID p2, jboolean p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetBooleanField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetBooleanField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.z = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetBooleanField")
    && bda_check_no_exeception(s, "SetBooleanField")
    && bda_check_no_critical(s, "SetBooleanField")
    && bda_check_non_null(s, p1,  1, "SetBooleanField")
    && bda_check_non_null(s, p2,  2, "SetBooleanField")
    && bda_check_dref(s, p1, 1, "SetBooleanField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetBooleanField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'Z', "SetBooleanField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetBooleanField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetBooleanField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetBooleanField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetBooleanField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID) %d(jboolean)\n", "SetBooleanField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetBooleanField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetBooleanField", s->name)) {
    printf("<= %-50s\n", "SetBooleanField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetByteField*/
static void JNICALL bda_c2j_proxy_SetByteField(JNIEnv * env, jobject p1, jfieldID p2, jbyte p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetByteField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetByteField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.b = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetByteField")
    && bda_check_no_exeception(s, "SetByteField")
    && bda_check_no_critical(s, "SetByteField")
    && bda_check_non_null(s, p1,  1, "SetByteField")
    && bda_check_non_null(s, p2,  2, "SetByteField")
    && bda_check_dref(s, p1, 1, "SetByteField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetByteField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'B', "SetByteField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetByteField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetByteField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetByteField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetByteField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID) %d(jbyte)\n", "SetByteField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetByteField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetByteField", s->name)) {
    printf("<= %-50s\n", "SetByteField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetCharField*/
static void JNICALL bda_c2j_proxy_SetCharField(JNIEnv * env, jobject p1, jfieldID p2, jchar p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetCharField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetCharField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.c = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetCharField")
    && bda_check_no_exeception(s, "SetCharField")
    && bda_check_no_critical(s, "SetCharField")
    && bda_check_non_null(s, p1,  1, "SetCharField")
    && bda_check_non_null(s, p2,  2, "SetCharField")
    && bda_check_dref(s, p1, 1, "SetCharField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetCharField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'C', "SetCharField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetCharField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetCharField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetCharField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetCharField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID) %d(jchar)\n", "SetCharField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetCharField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetCharField", s->name)) {
    printf("<= %-50s\n", "SetCharField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetShortField*/
static void JNICALL bda_c2j_proxy_SetShortField(JNIEnv * env, jobject p1, jfieldID p2, jshort p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetShortField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetShortField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.s = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetShortField")
    && bda_check_no_exeception(s, "SetShortField")
    && bda_check_no_critical(s, "SetShortField")
    && bda_check_non_null(s, p1,  1, "SetShortField")
    && bda_check_non_null(s, p2,  2, "SetShortField")
    && bda_check_dref(s, p1, 1, "SetShortField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetShortField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'S', "SetShortField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetShortField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetShortField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetShortField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetShortField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID) %d(jshort)\n", "SetShortField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetShortField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetShortField", s->name)) {
    printf("<= %-50s\n", "SetShortField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetIntField*/
static void JNICALL bda_c2j_proxy_SetIntField(JNIEnv * env, jobject p1, jfieldID p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetIntField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetIntField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.i = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetIntField")
    && bda_check_no_exeception(s, "SetIntField")
    && bda_check_no_critical(s, "SetIntField")
    && bda_check_non_null(s, p1,  1, "SetIntField")
    && bda_check_non_null(s, p2,  2, "SetIntField")
    && bda_check_dref(s, p1, 1, "SetIntField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetIntField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'I', "SetIntField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetIntField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetIntField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetIntField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetIntField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID) %d(jint)\n", "SetIntField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetIntField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetIntField", s->name)) {
    printf("<= %-50s\n", "SetIntField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetLongField*/
static void JNICALL bda_c2j_proxy_SetLongField(JNIEnv * env, jobject p1, jfieldID p2, jlong p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetLongField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetLongField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.j = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetLongField")
    && bda_check_no_exeception(s, "SetLongField")
    && bda_check_no_critical(s, "SetLongField")
    && bda_check_non_null(s, p1,  1, "SetLongField")
    && bda_check_non_null(s, p2,  2, "SetLongField")
    && bda_check_dref(s, p1, 1, "SetLongField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetLongField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'J', "SetLongField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetLongField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetLongField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetLongField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetLongField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID) %lld(jlong)\n", "SetLongField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetLongField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetLongField", s->name)) {
    printf("<= %-50s\n", "SetLongField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetFloatField*/
static void JNICALL bda_c2j_proxy_SetFloatField(JNIEnv * env, jobject p1, jfieldID p2, jfloat p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetFloatField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetFloatField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.f = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetFloatField")
    && bda_check_no_exeception(s, "SetFloatField")
    && bda_check_no_critical(s, "SetFloatField")
    && bda_check_non_null(s, p1,  1, "SetFloatField")
    && bda_check_non_null(s, p2,  2, "SetFloatField")
    && bda_check_dref(s, p1, 1, "SetFloatField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetFloatField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'F', "SetFloatField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetFloatField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetFloatField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetFloatField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetFloatField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID) %f(jfloat)\n", "SetFloatField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetFloatField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetFloatField", s->name)) {
    printf("<= %-50s\n", "SetFloatField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetDoubleField*/
static void JNICALL bda_c2j_proxy_SetDoubleField(JNIEnv * env, jobject p1, jfieldID p2, jdouble p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetDoubleField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetDoubleField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.d = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetDoubleField")
    && bda_check_no_exeception(s, "SetDoubleField")
    && bda_check_no_critical(s, "SetDoubleField")
    && bda_check_non_null(s, p1,  1, "SetDoubleField")
    && bda_check_non_null(s, p2,  2, "SetDoubleField")
    && bda_check_dref(s, p1, 1, "SetDoubleField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetDoubleField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'D', "SetDoubleField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetDoubleField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetDoubleField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetDoubleField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetDoubleField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject) %p(jfieldID) %lf(jdouble)\n", "SetDoubleField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetDoubleField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetDoubleField", s->name)) {
    printf("<= %-50s\n", "SetDoubleField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for GetStaticMethodID*/
static jmethodID JNICALL bda_c2j_proxy_GetStaticMethodID(JNIEnv * env, jclass p1, const char * p2, const char * p3)
{
  /* local variables */
  jmethodID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStaticMethodID++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticMethodID++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticMethodID")
    && bda_check_no_exeception(s, "GetStaticMethodID")
    && bda_check_no_critical(s, "GetStaticMethodID")
    && bda_check_non_null(s, p1,  1, "GetStaticMethodID")
    && bda_check_non_null(s, p2,  2, "GetStaticMethodID")
    && bda_check_non_null(s, p3,  3, "GetStaticMethodID")
    && bda_check_dref(s, p1, 1, "GetStaticMethodID")
    && bda_check_jclass(s, p1, 1, "GetStaticMethodID")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticMethodID;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticMethodID", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %s(const char *) %s(const char *)\n", "GetStaticMethodID" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticMethodID(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticMethodID", s->name)) {
    printf("<= %-50s %p\n", "GetStaticMethodID", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
   if (result != NULL) {
       bda_jmethodid_append(result, 1, p1, p2, p3);
   }
  }

  return result;
}


/* proxy for CallStaticObjectMethod*/
static jobject JNICALL bda_c2j_proxy_CallStaticObjectMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticObjectMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticObjectMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticObjectMethod")
    && bda_check_no_exeception(s, "CallStaticObjectMethod")
    && bda_check_capacity_c2j_call(s, "CallStaticObjectMethod")
    && bda_check_no_critical(s, "CallStaticObjectMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticObjectMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticObjectMethod")
    && bda_check_dref(s, p1, 1, "CallStaticObjectMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticObjectMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticObjectMethod", 'O')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticObjectMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticObjectMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID)\n", "CallStaticObjectMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticObjectMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticObjectMethod", s->name)) {
    printf("<= %-50s %p\n", "CallStaticObjectMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for CallStaticObjectMethodV*/
static jobject JNICALL bda_c2j_proxy_CallStaticObjectMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticObjectMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticObjectMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticObjectMethodV")
    && bda_check_no_exeception(s, "CallStaticObjectMethodV")
    && bda_check_capacity_c2j_call(s, "CallStaticObjectMethodV")
    && bda_check_no_critical(s, "CallStaticObjectMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticObjectMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticObjectMethodV")
    && bda_check_dref(s, p1, 1, "CallStaticObjectMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticObjectMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticObjectMethodV", 'O')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticObjectMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticObjectMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallStaticObjectMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticObjectMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticObjectMethodV", s->name)) {
    printf("<= %-50s %p\n", "CallStaticObjectMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for CallStaticObjectMethodA*/
static jobject JNICALL bda_c2j_proxy_CallStaticObjectMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticObjectMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticObjectMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticObjectMethodA")
    && bda_check_no_exeception(s, "CallStaticObjectMethodA")
    && bda_check_capacity_c2j_call(s, "CallStaticObjectMethodA")
    && bda_check_no_critical(s, "CallStaticObjectMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticObjectMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticObjectMethodA")
    && bda_check_dref(s, p1, 1, "CallStaticObjectMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticObjectMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticObjectMethodA", 'O')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticObjectMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticObjectMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallStaticObjectMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticObjectMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticObjectMethodA", s->name)) {
    printf("<= %-50s %p\n", "CallStaticObjectMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for CallStaticBooleanMethod*/
static jboolean JNICALL bda_c2j_proxy_CallStaticBooleanMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticBooleanMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticBooleanMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticBooleanMethod")
    && bda_check_no_exeception(s, "CallStaticBooleanMethod")
    && bda_check_no_critical(s, "CallStaticBooleanMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticBooleanMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticBooleanMethod")
    && bda_check_dref(s, p1, 1, "CallStaticBooleanMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticBooleanMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticBooleanMethod", 'Z')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticBooleanMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticBooleanMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID)\n", "CallStaticBooleanMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticBooleanMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticBooleanMethod", s->name)) {
    printf("<= %-50s %d\n", "CallStaticBooleanMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticBooleanMethodV*/
static jboolean JNICALL bda_c2j_proxy_CallStaticBooleanMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticBooleanMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticBooleanMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticBooleanMethodV")
    && bda_check_no_exeception(s, "CallStaticBooleanMethodV")
    && bda_check_no_critical(s, "CallStaticBooleanMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticBooleanMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticBooleanMethodV")
    && bda_check_dref(s, p1, 1, "CallStaticBooleanMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticBooleanMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticBooleanMethodV", 'Z')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticBooleanMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticBooleanMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallStaticBooleanMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticBooleanMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticBooleanMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallStaticBooleanMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticBooleanMethodA*/
static jboolean JNICALL bda_c2j_proxy_CallStaticBooleanMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticBooleanMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticBooleanMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticBooleanMethodA")
    && bda_check_no_exeception(s, "CallStaticBooleanMethodA")
    && bda_check_no_critical(s, "CallStaticBooleanMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticBooleanMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticBooleanMethodA")
    && bda_check_dref(s, p1, 1, "CallStaticBooleanMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticBooleanMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticBooleanMethodA", 'Z')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticBooleanMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticBooleanMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallStaticBooleanMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticBooleanMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticBooleanMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallStaticBooleanMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticByteMethod*/
static jbyte JNICALL bda_c2j_proxy_CallStaticByteMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticByteMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticByteMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticByteMethod")
    && bda_check_no_exeception(s, "CallStaticByteMethod")
    && bda_check_no_critical(s, "CallStaticByteMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticByteMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticByteMethod")
    && bda_check_dref(s, p1, 1, "CallStaticByteMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticByteMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticByteMethod", 'B')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticByteMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticByteMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID)\n", "CallStaticByteMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticByteMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticByteMethod", s->name)) {
    printf("<= %-50s %d\n", "CallStaticByteMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticByteMethodV*/
static jbyte JNICALL bda_c2j_proxy_CallStaticByteMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticByteMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticByteMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticByteMethodV")
    && bda_check_no_exeception(s, "CallStaticByteMethodV")
    && bda_check_no_critical(s, "CallStaticByteMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticByteMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticByteMethodV")
    && bda_check_dref(s, p1, 1, "CallStaticByteMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticByteMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticByteMethodV", 'B')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticByteMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticByteMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallStaticByteMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticByteMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticByteMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallStaticByteMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticByteMethodA*/
static jbyte JNICALL bda_c2j_proxy_CallStaticByteMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticByteMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticByteMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticByteMethodA")
    && bda_check_no_exeception(s, "CallStaticByteMethodA")
    && bda_check_no_critical(s, "CallStaticByteMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticByteMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticByteMethodA")
    && bda_check_dref(s, p1, 1, "CallStaticByteMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticByteMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticByteMethodA", 'B')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticByteMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticByteMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallStaticByteMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticByteMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticByteMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallStaticByteMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticCharMethod*/
static jchar JNICALL bda_c2j_proxy_CallStaticCharMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticCharMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticCharMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticCharMethod")
    && bda_check_no_exeception(s, "CallStaticCharMethod")
    && bda_check_no_critical(s, "CallStaticCharMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticCharMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticCharMethod")
    && bda_check_dref(s, p1, 1, "CallStaticCharMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticCharMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticCharMethod", 'C')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticCharMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticCharMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID)\n", "CallStaticCharMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticCharMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticCharMethod", s->name)) {
    printf("<= %-50s %d\n", "CallStaticCharMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticCharMethodV*/
static jchar JNICALL bda_c2j_proxy_CallStaticCharMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticCharMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticCharMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticCharMethodV")
    && bda_check_no_exeception(s, "CallStaticCharMethodV")
    && bda_check_no_critical(s, "CallStaticCharMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticCharMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticCharMethodV")
    && bda_check_dref(s, p1, 1, "CallStaticCharMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticCharMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticCharMethodV", 'C')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticCharMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticCharMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallStaticCharMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticCharMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticCharMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallStaticCharMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticCharMethodA*/
static jchar JNICALL bda_c2j_proxy_CallStaticCharMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticCharMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticCharMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticCharMethodA")
    && bda_check_no_exeception(s, "CallStaticCharMethodA")
    && bda_check_no_critical(s, "CallStaticCharMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticCharMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticCharMethodA")
    && bda_check_dref(s, p1, 1, "CallStaticCharMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticCharMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticCharMethodA", 'C')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticCharMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticCharMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallStaticCharMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticCharMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticCharMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallStaticCharMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticShortMethod*/
static jshort JNICALL bda_c2j_proxy_CallStaticShortMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticShortMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticShortMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticShortMethod")
    && bda_check_no_exeception(s, "CallStaticShortMethod")
    && bda_check_no_critical(s, "CallStaticShortMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticShortMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticShortMethod")
    && bda_check_dref(s, p1, 1, "CallStaticShortMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticShortMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticShortMethod", 'S')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticShortMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticShortMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID)\n", "CallStaticShortMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticShortMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticShortMethod", s->name)) {
    printf("<= %-50s %d\n", "CallStaticShortMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticShortMethodV*/
static jshort JNICALL bda_c2j_proxy_CallStaticShortMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticShortMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticShortMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticShortMethodV")
    && bda_check_no_exeception(s, "CallStaticShortMethodV")
    && bda_check_no_critical(s, "CallStaticShortMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticShortMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticShortMethodV")
    && bda_check_dref(s, p1, 1, "CallStaticShortMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticShortMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticShortMethodV", 'S')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticShortMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticShortMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallStaticShortMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticShortMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticShortMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallStaticShortMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticShortMethodA*/
static jshort JNICALL bda_c2j_proxy_CallStaticShortMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticShortMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticShortMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticShortMethodA")
    && bda_check_no_exeception(s, "CallStaticShortMethodA")
    && bda_check_no_critical(s, "CallStaticShortMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticShortMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticShortMethodA")
    && bda_check_dref(s, p1, 1, "CallStaticShortMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticShortMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticShortMethodA", 'S')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticShortMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticShortMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallStaticShortMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticShortMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticShortMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallStaticShortMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticIntMethod*/
static jint JNICALL bda_c2j_proxy_CallStaticIntMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticIntMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticIntMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticIntMethod")
    && bda_check_no_exeception(s, "CallStaticIntMethod")
    && bda_check_no_critical(s, "CallStaticIntMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticIntMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticIntMethod")
    && bda_check_dref(s, p1, 1, "CallStaticIntMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticIntMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticIntMethod", 'I')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticIntMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticIntMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID)\n", "CallStaticIntMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticIntMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticIntMethod", s->name)) {
    printf("<= %-50s %d\n", "CallStaticIntMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticIntMethodV*/
static jint JNICALL bda_c2j_proxy_CallStaticIntMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticIntMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticIntMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticIntMethodV")
    && bda_check_no_exeception(s, "CallStaticIntMethodV")
    && bda_check_no_critical(s, "CallStaticIntMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticIntMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticIntMethodV")
    && bda_check_dref(s, p1, 1, "CallStaticIntMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticIntMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticIntMethodV", 'I')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticIntMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticIntMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallStaticIntMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticIntMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticIntMethodV", s->name)) {
    printf("<= %-50s %d\n", "CallStaticIntMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticIntMethodA*/
static jint JNICALL bda_c2j_proxy_CallStaticIntMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticIntMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticIntMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticIntMethodA")
    && bda_check_no_exeception(s, "CallStaticIntMethodA")
    && bda_check_no_critical(s, "CallStaticIntMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticIntMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticIntMethodA")
    && bda_check_dref(s, p1, 1, "CallStaticIntMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticIntMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticIntMethodA", 'I')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticIntMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticIntMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallStaticIntMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticIntMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticIntMethodA", s->name)) {
    printf("<= %-50s %d\n", "CallStaticIntMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticLongMethod*/
static jlong JNICALL bda_c2j_proxy_CallStaticLongMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticLongMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticLongMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticLongMethod")
    && bda_check_no_exeception(s, "CallStaticLongMethod")
    && bda_check_no_critical(s, "CallStaticLongMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticLongMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticLongMethod")
    && bda_check_dref(s, p1, 1, "CallStaticLongMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticLongMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticLongMethod", 'J')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticLongMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticLongMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID)\n", "CallStaticLongMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticLongMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticLongMethod", s->name)) {
    printf("<= %-50s %lld\n", "CallStaticLongMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticLongMethodV*/
static jlong JNICALL bda_c2j_proxy_CallStaticLongMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticLongMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticLongMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticLongMethodV")
    && bda_check_no_exeception(s, "CallStaticLongMethodV")
    && bda_check_no_critical(s, "CallStaticLongMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticLongMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticLongMethodV")
    && bda_check_dref(s, p1, 1, "CallStaticLongMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticLongMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticLongMethodV", 'J')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticLongMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticLongMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallStaticLongMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticLongMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticLongMethodV", s->name)) {
    printf("<= %-50s %lld\n", "CallStaticLongMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticLongMethodA*/
static jlong JNICALL bda_c2j_proxy_CallStaticLongMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticLongMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticLongMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticLongMethodA")
    && bda_check_no_exeception(s, "CallStaticLongMethodA")
    && bda_check_no_critical(s, "CallStaticLongMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticLongMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticLongMethodA")
    && bda_check_dref(s, p1, 1, "CallStaticLongMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticLongMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticLongMethodA", 'J')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticLongMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticLongMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallStaticLongMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticLongMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticLongMethodA", s->name)) {
    printf("<= %-50s %lld\n", "CallStaticLongMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticFloatMethod*/
static jfloat JNICALL bda_c2j_proxy_CallStaticFloatMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticFloatMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticFloatMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticFloatMethod")
    && bda_check_no_exeception(s, "CallStaticFloatMethod")
    && bda_check_no_critical(s, "CallStaticFloatMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticFloatMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticFloatMethod")
    && bda_check_dref(s, p1, 1, "CallStaticFloatMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticFloatMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticFloatMethod", 'F')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticFloatMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticFloatMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID)\n", "CallStaticFloatMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticFloatMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticFloatMethod", s->name)) {
    printf("<= %-50s %f\n", "CallStaticFloatMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticFloatMethodV*/
static jfloat JNICALL bda_c2j_proxy_CallStaticFloatMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticFloatMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticFloatMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticFloatMethodV")
    && bda_check_no_exeception(s, "CallStaticFloatMethodV")
    && bda_check_no_critical(s, "CallStaticFloatMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticFloatMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticFloatMethodV")
    && bda_check_dref(s, p1, 1, "CallStaticFloatMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticFloatMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticFloatMethodV", 'F')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticFloatMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticFloatMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallStaticFloatMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticFloatMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticFloatMethodV", s->name)) {
    printf("<= %-50s %f\n", "CallStaticFloatMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticFloatMethodA*/
static jfloat JNICALL bda_c2j_proxy_CallStaticFloatMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticFloatMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticFloatMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticFloatMethodA")
    && bda_check_no_exeception(s, "CallStaticFloatMethodA")
    && bda_check_no_critical(s, "CallStaticFloatMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticFloatMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticFloatMethodA")
    && bda_check_dref(s, p1, 1, "CallStaticFloatMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticFloatMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticFloatMethodA", 'F')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticFloatMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticFloatMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallStaticFloatMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticFloatMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticFloatMethodA", s->name)) {
    printf("<= %-50s %f\n", "CallStaticFloatMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticDoubleMethod*/
static jdouble JNICALL bda_c2j_proxy_CallStaticDoubleMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticDoubleMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticDoubleMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticDoubleMethod")
    && bda_check_no_exeception(s, "CallStaticDoubleMethod")
    && bda_check_no_critical(s, "CallStaticDoubleMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticDoubleMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticDoubleMethod")
    && bda_check_dref(s, p1, 1, "CallStaticDoubleMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticDoubleMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticDoubleMethod", 'D')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticDoubleMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticDoubleMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID)\n", "CallStaticDoubleMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticDoubleMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticDoubleMethod", s->name)) {
    printf("<= %-50s %lf\n", "CallStaticDoubleMethod", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticDoubleMethodV*/
static jdouble JNICALL bda_c2j_proxy_CallStaticDoubleMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticDoubleMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticDoubleMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticDoubleMethodV")
    && bda_check_no_exeception(s, "CallStaticDoubleMethodV")
    && bda_check_no_critical(s, "CallStaticDoubleMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticDoubleMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticDoubleMethodV")
    && bda_check_dref(s, p1, 1, "CallStaticDoubleMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticDoubleMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticDoubleMethodV", 'D')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticDoubleMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticDoubleMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallStaticDoubleMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticDoubleMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticDoubleMethodV", s->name)) {
    printf("<= %-50s %lf\n", "CallStaticDoubleMethodV", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticDoubleMethodA*/
static jdouble JNICALL bda_c2j_proxy_CallStaticDoubleMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticDoubleMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticDoubleMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticDoubleMethodA")
    && bda_check_no_exeception(s, "CallStaticDoubleMethodA")
    && bda_check_no_critical(s, "CallStaticDoubleMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticDoubleMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticDoubleMethodA")
    && bda_check_dref(s, p1, 1, "CallStaticDoubleMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticDoubleMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticDoubleMethodA", 'D')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticDoubleMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticDoubleMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallStaticDoubleMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticDoubleMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticDoubleMethodA", s->name)) {
    printf("<= %-50s %lf\n", "CallStaticDoubleMethodA", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticVoidMethod*/
static void JNICALL bda_c2j_proxy_CallStaticVoidMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  va_list args;
  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticVoidMethod++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticVoidMethod++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticVoidMethod")
    && bda_check_no_exeception(s, "CallStaticVoidMethod")
    && bda_check_no_critical(s, "CallStaticVoidMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticVoidMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticVoidMethod")
    && bda_check_dref(s, p1, 1, "CallStaticVoidMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticVoidMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticVoidMethod", 'V')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticVoidMethod;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticVoidMethod", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID)\n", "CallStaticVoidMethod" , env, p1, p2);
    va_start(args,p2);
    bda_jmethod_print_argument_from_va_list(env, p2, args);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  bda_orig_jni_funcs->CallStaticVoidMethodV(env, p1, p2, args);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticVoidMethod", s->name)) {
    printf("<= %-50s\n", "CallStaticVoidMethod");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for CallStaticVoidMethodV*/
static void JNICALL bda_c2j_proxy_CallStaticVoidMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticVoidMethodV++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticVoidMethodV++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticVoidMethodV")
    && bda_check_no_exeception(s, "CallStaticVoidMethodV")
    && bda_check_no_critical(s, "CallStaticVoidMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticVoidMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticVoidMethodV")
    && bda_check_dref(s, p1, 1, "CallStaticVoidMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticVoidMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticVoidMethodV", 'V')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticVoidMethodV;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticVoidMethodV", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(va_list)\n", "CallStaticVoidMethodV" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_va_list(env, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallStaticVoidMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticVoidMethodV", s->name)) {
    printf("<= %-50s\n", "CallStaticVoidMethodV");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for CallStaticVoidMethodA*/
static void JNICALL bda_c2j_proxy_CallStaticVoidMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.CallStaticVoidMethodA++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticVoidMethodA++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticVoidMethodA")
    && bda_check_no_exeception(s, "CallStaticVoidMethodA")
    && bda_check_no_critical(s, "CallStaticVoidMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticVoidMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticVoidMethodA")
    && bda_check_dref(s, p1, 1, "CallStaticVoidMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticVoidMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticVoidMethodA", 'V')
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticVoidMethodA;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticVoidMethodA", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jmethodID) %p(const jvalue *)\n", "CallStaticVoidMethodA" , env, p1, p2, p3);
    bda_jmethod_print_argument_from_array(env, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallStaticVoidMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("CallStaticVoidMethodA", s->name)) {
    printf("<= %-50s\n", "CallStaticVoidMethodA");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for GetStaticFieldID*/
static jfieldID JNICALL bda_c2j_proxy_GetStaticFieldID(JNIEnv * env, jclass p1, const char * p2, const char * p3)
{
  /* local variables */
  jfieldID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStaticFieldID++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticFieldID++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticFieldID")
    && bda_check_no_exeception(s, "GetStaticFieldID")
    && bda_check_no_critical(s, "GetStaticFieldID")
    && bda_check_non_null(s, p1,  1, "GetStaticFieldID")
    && bda_check_non_null(s, p2,  2, "GetStaticFieldID")
    && bda_check_non_null(s, p3,  3, "GetStaticFieldID")
    && bda_check_dref(s, p1, 1, "GetStaticFieldID")
    && bda_check_jclass(s, p1, 1, "GetStaticFieldID")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticFieldID;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticFieldID", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %s(const char *) %s(const char *)\n", "GetStaticFieldID" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticFieldID(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticFieldID", s->name)) {
    printf("<= %-50s %p\n", "GetStaticFieldID", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
   if (result != NULL) {
       bda_jfieldid_append(s, result, p1, 1, p2, p3);
   }
  }

  return result;
}


/* proxy for GetStaticObjectField*/
static jobject JNICALL bda_c2j_proxy_GetStaticObjectField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStaticObjectField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticObjectField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticObjectField")
    && bda_check_no_exeception(s, "GetStaticObjectField")
    && bda_check_capacity_c2j_call(s, "GetStaticObjectField")
    && bda_check_no_critical(s, "GetStaticObjectField")
    && bda_check_non_null(s, p1,  1, "GetStaticObjectField")
    && bda_check_non_null(s, p2,  2, "GetStaticObjectField")
    && bda_check_dref(s, p1, 1, "GetStaticObjectField")
    && bda_check_jclass(s, p1, 1, "GetStaticObjectField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'O', "GetStaticObjectField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticObjectField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticObjectField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID)\n", "GetStaticObjectField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticObjectField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticObjectField", s->name)) {
    printf("<= %-50s %p\n", "GetStaticObjectField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for GetStaticBooleanField*/
static jboolean JNICALL bda_c2j_proxy_GetStaticBooleanField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStaticBooleanField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticBooleanField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticBooleanField")
    && bda_check_no_exeception(s, "GetStaticBooleanField")
    && bda_check_no_critical(s, "GetStaticBooleanField")
    && bda_check_non_null(s, p1,  1, "GetStaticBooleanField")
    && bda_check_non_null(s, p2,  2, "GetStaticBooleanField")
    && bda_check_dref(s, p1, 1, "GetStaticBooleanField")
    && bda_check_jclass(s, p1, 1, "GetStaticBooleanField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'Z', "GetStaticBooleanField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticBooleanField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticBooleanField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID)\n", "GetStaticBooleanField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticBooleanField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticBooleanField", s->name)) {
    printf("<= %-50s %d\n", "GetStaticBooleanField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticByteField*/
static jbyte JNICALL bda_c2j_proxy_GetStaticByteField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStaticByteField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticByteField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticByteField")
    && bda_check_no_exeception(s, "GetStaticByteField")
    && bda_check_no_critical(s, "GetStaticByteField")
    && bda_check_non_null(s, p1,  1, "GetStaticByteField")
    && bda_check_non_null(s, p2,  2, "GetStaticByteField")
    && bda_check_dref(s, p1, 1, "GetStaticByteField")
    && bda_check_jclass(s, p1, 1, "GetStaticByteField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'B', "GetStaticByteField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticByteField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticByteField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID)\n", "GetStaticByteField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticByteField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticByteField", s->name)) {
    printf("<= %-50s %d\n", "GetStaticByteField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticCharField*/
static jchar JNICALL bda_c2j_proxy_GetStaticCharField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStaticCharField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticCharField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticCharField")
    && bda_check_no_exeception(s, "GetStaticCharField")
    && bda_check_no_critical(s, "GetStaticCharField")
    && bda_check_non_null(s, p1,  1, "GetStaticCharField")
    && bda_check_non_null(s, p2,  2, "GetStaticCharField")
    && bda_check_dref(s, p1, 1, "GetStaticCharField")
    && bda_check_jclass(s, p1, 1, "GetStaticCharField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'C', "GetStaticCharField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticCharField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticCharField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID)\n", "GetStaticCharField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticCharField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticCharField", s->name)) {
    printf("<= %-50s %d\n", "GetStaticCharField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticShortField*/
static jshort JNICALL bda_c2j_proxy_GetStaticShortField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStaticShortField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticShortField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticShortField")
    && bda_check_no_exeception(s, "GetStaticShortField")
    && bda_check_no_critical(s, "GetStaticShortField")
    && bda_check_non_null(s, p1,  1, "GetStaticShortField")
    && bda_check_non_null(s, p2,  2, "GetStaticShortField")
    && bda_check_dref(s, p1, 1, "GetStaticShortField")
    && bda_check_jclass(s, p1, 1, "GetStaticShortField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'S', "GetStaticShortField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticShortField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticShortField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID)\n", "GetStaticShortField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticShortField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticShortField", s->name)) {
    printf("<= %-50s %d\n", "GetStaticShortField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticIntField*/
static jint JNICALL bda_c2j_proxy_GetStaticIntField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStaticIntField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticIntField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticIntField")
    && bda_check_no_exeception(s, "GetStaticIntField")
    && bda_check_no_critical(s, "GetStaticIntField")
    && bda_check_non_null(s, p1,  1, "GetStaticIntField")
    && bda_check_non_null(s, p2,  2, "GetStaticIntField")
    && bda_check_dref(s, p1, 1, "GetStaticIntField")
    && bda_check_jclass(s, p1, 1, "GetStaticIntField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'I', "GetStaticIntField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticIntField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticIntField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID)\n", "GetStaticIntField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticIntField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticIntField", s->name)) {
    printf("<= %-50s %d\n", "GetStaticIntField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticLongField*/
static jlong JNICALL bda_c2j_proxy_GetStaticLongField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStaticLongField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticLongField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticLongField")
    && bda_check_no_exeception(s, "GetStaticLongField")
    && bda_check_no_critical(s, "GetStaticLongField")
    && bda_check_non_null(s, p1,  1, "GetStaticLongField")
    && bda_check_non_null(s, p2,  2, "GetStaticLongField")
    && bda_check_dref(s, p1, 1, "GetStaticLongField")
    && bda_check_jclass(s, p1, 1, "GetStaticLongField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'J', "GetStaticLongField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticLongField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticLongField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID)\n", "GetStaticLongField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticLongField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticLongField", s->name)) {
    printf("<= %-50s %lld\n", "GetStaticLongField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticFloatField*/
static jfloat JNICALL bda_c2j_proxy_GetStaticFloatField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStaticFloatField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticFloatField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticFloatField")
    && bda_check_no_exeception(s, "GetStaticFloatField")
    && bda_check_no_critical(s, "GetStaticFloatField")
    && bda_check_non_null(s, p1,  1, "GetStaticFloatField")
    && bda_check_non_null(s, p2,  2, "GetStaticFloatField")
    && bda_check_dref(s, p1, 1, "GetStaticFloatField")
    && bda_check_jclass(s, p1, 1, "GetStaticFloatField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'F', "GetStaticFloatField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticFloatField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticFloatField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID)\n", "GetStaticFloatField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticFloatField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticFloatField", s->name)) {
    printf("<= %-50s %f\n", "GetStaticFloatField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticDoubleField*/
static jdouble JNICALL bda_c2j_proxy_GetStaticDoubleField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStaticDoubleField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticDoubleField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticDoubleField")
    && bda_check_no_exeception(s, "GetStaticDoubleField")
    && bda_check_no_critical(s, "GetStaticDoubleField")
    && bda_check_non_null(s, p1,  1, "GetStaticDoubleField")
    && bda_check_non_null(s, p2,  2, "GetStaticDoubleField")
    && bda_check_dref(s, p1, 1, "GetStaticDoubleField")
    && bda_check_jclass(s, p1, 1, "GetStaticDoubleField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'D', "GetStaticDoubleField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticDoubleField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticDoubleField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID)\n", "GetStaticDoubleField" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticDoubleField(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStaticDoubleField", s->name)) {
    printf("<= %-50s %lf\n", "GetStaticDoubleField", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for SetStaticObjectField*/
static void JNICALL bda_c2j_proxy_SetStaticObjectField(JNIEnv * env, jclass p1, jfieldID p2, jobject p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetStaticObjectField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticObjectField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.l = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticObjectField")
    && bda_check_no_exeception(s, "SetStaticObjectField")
    && bda_check_no_critical(s, "SetStaticObjectField")
    && bda_check_non_null(s, p1,  1, "SetStaticObjectField")
    && bda_check_non_null(s, p2,  2, "SetStaticObjectField")
    && bda_check_dref(s, p1, 1, "SetStaticObjectField")
    && bda_check_jclass(s, p1, 1, "SetStaticObjectField")
    && bda_check_dref(s, p3, 3, "SetStaticObjectField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticObjectField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'O', "SetStaticObjectField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticObjectField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticObjectField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticObjectField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticObjectField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID) %p(jobject)\n", "SetStaticObjectField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticObjectField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticObjectField", s->name)) {
    printf("<= %-50s\n", "SetStaticObjectField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticBooleanField*/
static void JNICALL bda_c2j_proxy_SetStaticBooleanField(JNIEnv * env, jclass p1, jfieldID p2, jboolean p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetStaticBooleanField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticBooleanField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.z = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticBooleanField")
    && bda_check_no_exeception(s, "SetStaticBooleanField")
    && bda_check_no_critical(s, "SetStaticBooleanField")
    && bda_check_non_null(s, p1,  1, "SetStaticBooleanField")
    && bda_check_non_null(s, p2,  2, "SetStaticBooleanField")
    && bda_check_dref(s, p1, 1, "SetStaticBooleanField")
    && bda_check_jclass(s, p1, 1, "SetStaticBooleanField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticBooleanField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'Z', "SetStaticBooleanField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticBooleanField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticBooleanField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticBooleanField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticBooleanField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID) %d(jboolean)\n", "SetStaticBooleanField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticBooleanField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticBooleanField", s->name)) {
    printf("<= %-50s\n", "SetStaticBooleanField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticByteField*/
static void JNICALL bda_c2j_proxy_SetStaticByteField(JNIEnv * env, jclass p1, jfieldID p2, jbyte p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetStaticByteField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticByteField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.b = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticByteField")
    && bda_check_no_exeception(s, "SetStaticByteField")
    && bda_check_no_critical(s, "SetStaticByteField")
    && bda_check_non_null(s, p1,  1, "SetStaticByteField")
    && bda_check_non_null(s, p2,  2, "SetStaticByteField")
    && bda_check_dref(s, p1, 1, "SetStaticByteField")
    && bda_check_jclass(s, p1, 1, "SetStaticByteField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticByteField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'B', "SetStaticByteField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticByteField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticByteField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticByteField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticByteField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID) %d(jbyte)\n", "SetStaticByteField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticByteField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticByteField", s->name)) {
    printf("<= %-50s\n", "SetStaticByteField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticCharField*/
static void JNICALL bda_c2j_proxy_SetStaticCharField(JNIEnv * env, jclass p1, jfieldID p2, jchar p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetStaticCharField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticCharField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.c = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticCharField")
    && bda_check_no_exeception(s, "SetStaticCharField")
    && bda_check_no_critical(s, "SetStaticCharField")
    && bda_check_non_null(s, p1,  1, "SetStaticCharField")
    && bda_check_non_null(s, p2,  2, "SetStaticCharField")
    && bda_check_dref(s, p1, 1, "SetStaticCharField")
    && bda_check_jclass(s, p1, 1, "SetStaticCharField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticCharField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'C', "SetStaticCharField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticCharField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticCharField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticCharField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticCharField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID) %d(jchar)\n", "SetStaticCharField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticCharField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticCharField", s->name)) {
    printf("<= %-50s\n", "SetStaticCharField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticShortField*/
static void JNICALL bda_c2j_proxy_SetStaticShortField(JNIEnv * env, jclass p1, jfieldID p2, jshort p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetStaticShortField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticShortField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.s = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticShortField")
    && bda_check_no_exeception(s, "SetStaticShortField")
    && bda_check_no_critical(s, "SetStaticShortField")
    && bda_check_non_null(s, p1,  1, "SetStaticShortField")
    && bda_check_non_null(s, p2,  2, "SetStaticShortField")
    && bda_check_dref(s, p1, 1, "SetStaticShortField")
    && bda_check_jclass(s, p1, 1, "SetStaticShortField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticShortField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'S', "SetStaticShortField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticShortField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticShortField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticShortField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticShortField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID) %d(jshort)\n", "SetStaticShortField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticShortField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticShortField", s->name)) {
    printf("<= %-50s\n", "SetStaticShortField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticIntField*/
static void JNICALL bda_c2j_proxy_SetStaticIntField(JNIEnv * env, jclass p1, jfieldID p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetStaticIntField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticIntField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.i = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticIntField")
    && bda_check_no_exeception(s, "SetStaticIntField")
    && bda_check_no_critical(s, "SetStaticIntField")
    && bda_check_non_null(s, p1,  1, "SetStaticIntField")
    && bda_check_non_null(s, p2,  2, "SetStaticIntField")
    && bda_check_dref(s, p1, 1, "SetStaticIntField")
    && bda_check_jclass(s, p1, 1, "SetStaticIntField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticIntField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'I', "SetStaticIntField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticIntField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticIntField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticIntField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticIntField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID) %d(jint)\n", "SetStaticIntField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticIntField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticIntField", s->name)) {
    printf("<= %-50s\n", "SetStaticIntField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticLongField*/
static void JNICALL bda_c2j_proxy_SetStaticLongField(JNIEnv * env, jclass p1, jfieldID p2, jlong p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetStaticLongField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticLongField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.j = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticLongField")
    && bda_check_no_exeception(s, "SetStaticLongField")
    && bda_check_no_critical(s, "SetStaticLongField")
    && bda_check_non_null(s, p1,  1, "SetStaticLongField")
    && bda_check_non_null(s, p2,  2, "SetStaticLongField")
    && bda_check_dref(s, p1, 1, "SetStaticLongField")
    && bda_check_jclass(s, p1, 1, "SetStaticLongField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticLongField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'J', "SetStaticLongField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticLongField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticLongField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticLongField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticLongField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID) %lld(jlong)\n", "SetStaticLongField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticLongField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticLongField", s->name)) {
    printf("<= %-50s\n", "SetStaticLongField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticFloatField*/
static void JNICALL bda_c2j_proxy_SetStaticFloatField(JNIEnv * env, jclass p1, jfieldID p2, jfloat p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetStaticFloatField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticFloatField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.f = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticFloatField")
    && bda_check_no_exeception(s, "SetStaticFloatField")
    && bda_check_no_critical(s, "SetStaticFloatField")
    && bda_check_non_null(s, p1,  1, "SetStaticFloatField")
    && bda_check_non_null(s, p2,  2, "SetStaticFloatField")
    && bda_check_dref(s, p1, 1, "SetStaticFloatField")
    && bda_check_jclass(s, p1, 1, "SetStaticFloatField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticFloatField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'F', "SetStaticFloatField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticFloatField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticFloatField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticFloatField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticFloatField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID) %f(jfloat)\n", "SetStaticFloatField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticFloatField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticFloatField", s->name)) {
    printf("<= %-50s\n", "SetStaticFloatField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticDoubleField*/
static void JNICALL bda_c2j_proxy_SetStaticDoubleField(JNIEnv * env, jclass p1, jfieldID p2, jdouble p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetStaticDoubleField++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticDoubleField++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.d = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticDoubleField")
    && bda_check_no_exeception(s, "SetStaticDoubleField")
    && bda_check_no_critical(s, "SetStaticDoubleField")
    && bda_check_non_null(s, p1,  1, "SetStaticDoubleField")
    && bda_check_non_null(s, p2,  2, "SetStaticDoubleField")
    && bda_check_dref(s, p1, 1, "SetStaticDoubleField")
    && bda_check_jclass(s, p1, 1, "SetStaticDoubleField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticDoubleField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'D', "SetStaticDoubleField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticDoubleField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticDoubleField")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticDoubleField;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticDoubleField", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(jfieldID) %lf(jdouble)\n", "SetStaticDoubleField" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticDoubleField(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetStaticDoubleField", s->name)) {
    printf("<= %-50s\n", "SetStaticDoubleField");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for NewString*/
static jstring JNICALL bda_c2j_proxy_NewString(JNIEnv * env, const jchar * p1, jsize p2)
{
  /* local variables */
  jstring result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewString++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewString++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewString")
    && bda_check_no_exeception(s, "NewString")
    && bda_check_capacity_c2j_call(s, "NewString")
    && bda_check_no_critical(s, "NewString")
    && bda_check_non_null(s, p1,  1, "NewString")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewString;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewString", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(const jchar *) %d(jsize)\n", "NewString" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewString(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewString", s->name)) {
    printf("<= %-50s %p\n", "NewString", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for GetStringLength*/
static jsize JNICALL bda_c2j_proxy_GetStringLength(JNIEnv * env, jstring p1)
{
  /* local variables */
  jsize result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStringLength++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringLength++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringLength")
    && bda_check_no_exeception(s, "GetStringLength")
    && bda_check_no_critical(s, "GetStringLength")
    && bda_check_non_null(s, p1,  1, "GetStringLength")
    && bda_check_dref(s, p1, 1, "GetStringLength")
    && bda_check_jstring(s, p1, 1, "GetStringLength")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringLength;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringLength", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jstring)\n", "GetStringLength" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringLength(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringLength", s->name)) {
    printf("<= %-50s %d\n", "GetStringLength", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStringChars*/
static const jchar * JNICALL bda_c2j_proxy_GetStringChars(JNIEnv * env, jstring p1, jboolean * p2)
{
  /* local variables */
  const jchar * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStringChars++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringChars++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringChars")
    && bda_check_no_exeception(s, "GetStringChars")
    && bda_check_no_critical(s, "GetStringChars")
    && bda_check_non_null(s, p1,  1, "GetStringChars")
    && bda_check_dref(s, p1, 1, "GetStringChars")
    && bda_check_jstring(s, p1, 1, "GetStringChars")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringChars;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringChars", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jstring) %p(jboolean *)\n", "GetStringChars" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringChars(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringChars", s->name)) {
    printf("<= %-50s %p\n", "GetStringChars", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetStringChars");}
  }

  return result;
}


/* proxy for ReleaseStringChars*/
static void JNICALL bda_c2j_proxy_ReleaseStringChars(JNIEnv * env, jstring p1, const jchar * p2)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ReleaseStringChars++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseStringChars++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseStringChars")
    && bda_check_no_critical(s, "ReleaseStringChars")
    && bda_check_non_null(s, p1,  1, "ReleaseStringChars")
    && bda_check_non_null(s, p2,  2, "ReleaseStringChars")
    && bda_check_resource_free(s, p2, "ReleaseStringChars")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseStringChars;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseStringChars", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jstring) %p(const jchar *)\n", "ReleaseStringChars" , env, p1, p2);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseStringChars(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseStringChars", s->name)) {
    printf("<= %-50s\n", "ReleaseStringChars");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    bda_resource_release(s, p2, "ReleaseStringChars");
  }

}


/* proxy for NewStringUTF*/
static jstring JNICALL bda_c2j_proxy_NewStringUTF(JNIEnv * env, const char * p1)
{
  /* local variables */
  jstring result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewStringUTF++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewStringUTF++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewStringUTF")
    && bda_check_no_exeception(s, "NewStringUTF")
    && bda_check_capacity_c2j_call(s, "NewStringUTF")
    && bda_check_no_critical(s, "NewStringUTF")
    && bda_check_non_null(s, p1,  1, "NewStringUTF")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewStringUTF;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewStringUTF", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %s(const char *)\n", "NewStringUTF" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewStringUTF(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewStringUTF", s->name)) {
    printf("<= %-50s %p\n", "NewStringUTF", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for GetStringUTFLength*/
static jsize JNICALL bda_c2j_proxy_GetStringUTFLength(JNIEnv * env, jstring p1)
{
  /* local variables */
  jsize result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStringUTFLength++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringUTFLength++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringUTFLength")
    && bda_check_no_exeception(s, "GetStringUTFLength")
    && bda_check_no_critical(s, "GetStringUTFLength")
    && bda_check_non_null(s, p1,  1, "GetStringUTFLength")
    && bda_check_dref(s, p1, 1, "GetStringUTFLength")
    && bda_check_jstring(s, p1, 1, "GetStringUTFLength")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringUTFLength;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringUTFLength", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jstring)\n", "GetStringUTFLength" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringUTFLength(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringUTFLength", s->name)) {
    printf("<= %-50s %d\n", "GetStringUTFLength", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStringUTFChars*/
static const char * JNICALL bda_c2j_proxy_GetStringUTFChars(JNIEnv * env, jstring p1, jboolean * p2)
{
  /* local variables */
  const char * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStringUTFChars++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringUTFChars++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringUTFChars")
    && bda_check_no_exeception(s, "GetStringUTFChars")
    && bda_check_no_critical(s, "GetStringUTFChars")
    && bda_check_non_null(s, p1,  1, "GetStringUTFChars")
    && bda_check_dref(s, p1, 1, "GetStringUTFChars")
    && bda_check_jstring(s, p1, 1, "GetStringUTFChars")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringUTFChars;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringUTFChars", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jstring) %p(jboolean *)\n", "GetStringUTFChars" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringUTFChars(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringUTFChars", s->name)) {
    printf("<= %-50s %s\n", "GetStringUTFChars", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetStringUTFChars");}
  }

  return result;
}


/* proxy for ReleaseStringUTFChars*/
static void JNICALL bda_c2j_proxy_ReleaseStringUTFChars(JNIEnv * env, jstring p1, const char * p2)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ReleaseStringUTFChars++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseStringUTFChars++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseStringUTFChars")
    && bda_check_no_critical(s, "ReleaseStringUTFChars")
    && bda_check_non_null(s, p1,  1, "ReleaseStringUTFChars")
    && bda_check_non_null(s, p2,  2, "ReleaseStringUTFChars")
    && bda_check_resource_free(s, p2, "ReleaseStringUTFChars")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseStringUTFChars;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseStringUTFChars", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jstring) %s(const char *)\n", "ReleaseStringUTFChars" , env, p1, p2);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseStringUTFChars(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseStringUTFChars", s->name)) {
    printf("<= %-50s\n", "ReleaseStringUTFChars");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    bda_resource_release(s, p2, "ReleaseStringUTFChars");
  }

}


/* proxy for GetArrayLength*/
static jsize JNICALL bda_c2j_proxy_GetArrayLength(JNIEnv * env, jarray p1)
{
  /* local variables */
  jsize result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetArrayLength++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetArrayLength++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetArrayLength")
    && bda_check_no_exeception(s, "GetArrayLength")
    && bda_check_no_critical(s, "GetArrayLength")
    && bda_check_non_null(s, p1,  1, "GetArrayLength")
    && bda_check_dref(s, p1, 1, "GetArrayLength")
    && bda_check_jarray(s, p1, 1, "GetArrayLength")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetArrayLength;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetArrayLength", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jarray)\n", "GetArrayLength" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetArrayLength(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetArrayLength", s->name)) {
    printf("<= %-50s %d\n", "GetArrayLength", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for NewObjectArray*/
static jobjectArray JNICALL bda_c2j_proxy_NewObjectArray(JNIEnv * env, jsize p1, jclass p2, jobject p3)
{
  /* local variables */
  jobjectArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewObjectArray++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewObjectArray++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewObjectArray")
    && bda_check_no_exeception(s, "NewObjectArray")
    && bda_check_capacity_c2j_call(s, "NewObjectArray")
    && bda_check_no_critical(s, "NewObjectArray")
    && bda_check_non_null(s, p2,  2, "NewObjectArray")
    && bda_check_dref(s, p2, 2, "NewObjectArray")
    && bda_check_jclass(s, p2, 2, "NewObjectArray")
    && bda_check_dref(s, p3, 3, "NewObjectArray")
    && bda_check_assignable_jclass_jobject(s, p2, p3, 2, "NewObjectArray")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewObjectArray;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewObjectArray", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %d(jsize) %p(jclass) %p(jobject)\n", "NewObjectArray" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewObjectArray(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewObjectArray", s->name)) {
    printf("<= %-50s %p\n", "NewObjectArray", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for GetObjectArrayElement*/
static jobject JNICALL bda_c2j_proxy_GetObjectArrayElement(JNIEnv * env, jobjectArray p1, jsize p2)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetObjectArrayElement++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetObjectArrayElement++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetObjectArrayElement")
    && bda_check_no_exeception(s, "GetObjectArrayElement")
    && bda_check_capacity_c2j_call(s, "GetObjectArrayElement")
    && bda_check_no_critical(s, "GetObjectArrayElement")
    && bda_check_non_null(s, p1,  1, "GetObjectArrayElement")
    && bda_check_dref(s, p1, 1, "GetObjectArrayElement")
    && bda_check_jobjectArray(s, p1, 1, "GetObjectArrayElement")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetObjectArrayElement;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetObjectArrayElement", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobjectArray) %d(jsize)\n", "GetObjectArrayElement" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetObjectArrayElement(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetObjectArrayElement", s->name)) {
    printf("<= %-50s %p\n", "GetObjectArrayElement", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for SetObjectArrayElement*/
static void JNICALL bda_c2j_proxy_SetObjectArrayElement(JNIEnv * env, jobjectArray p1, jsize p2, jobject p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetObjectArrayElement++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetObjectArrayElement++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetObjectArrayElement")
    && bda_check_no_exeception(s, "SetObjectArrayElement")
    && bda_check_no_critical(s, "SetObjectArrayElement")
    && bda_check_non_null(s, p1,  1, "SetObjectArrayElement")
    && bda_check_non_null(s, p3,  3, "SetObjectArrayElement")
    && bda_check_dref(s, p1, 1, "SetObjectArrayElement")
    && bda_check_jobjectArray(s, p1, 1, "SetObjectArrayElement")
    && bda_check_dref(s, p3, 3, "SetObjectArrayElement")
    && bda_check_assignable_jobjectArray_jobject(s, p1, p3, 3,  "SetObjectArrayElement")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetObjectArrayElement;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetObjectArrayElement", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobjectArray) %d(jsize) %p(jobject)\n", "SetObjectArrayElement" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetObjectArrayElement(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetObjectArrayElement", s->name)) {
    printf("<= %-50s\n", "SetObjectArrayElement");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for NewBooleanArray*/
static jbooleanArray JNICALL bda_c2j_proxy_NewBooleanArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jbooleanArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewBooleanArray++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewBooleanArray++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewBooleanArray")
    && bda_check_no_exeception(s, "NewBooleanArray")
    && bda_check_capacity_c2j_call(s, "NewBooleanArray")
    && bda_check_no_critical(s, "NewBooleanArray")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewBooleanArray;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewBooleanArray", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %d(jsize)\n", "NewBooleanArray" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewBooleanArray(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewBooleanArray", s->name)) {
    printf("<= %-50s %p\n", "NewBooleanArray", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for NewByteArray*/
static jbyteArray JNICALL bda_c2j_proxy_NewByteArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jbyteArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewByteArray++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewByteArray++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewByteArray")
    && bda_check_no_exeception(s, "NewByteArray")
    && bda_check_capacity_c2j_call(s, "NewByteArray")
    && bda_check_no_critical(s, "NewByteArray")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewByteArray;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewByteArray", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %d(jsize)\n", "NewByteArray" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewByteArray(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewByteArray", s->name)) {
    printf("<= %-50s %p\n", "NewByteArray", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for NewCharArray*/
static jcharArray JNICALL bda_c2j_proxy_NewCharArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jcharArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewCharArray++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewCharArray++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewCharArray")
    && bda_check_no_exeception(s, "NewCharArray")
    && bda_check_capacity_c2j_call(s, "NewCharArray")
    && bda_check_no_critical(s, "NewCharArray")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewCharArray;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewCharArray", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %d(jsize)\n", "NewCharArray" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewCharArray(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewCharArray", s->name)) {
    printf("<= %-50s %p\n", "NewCharArray", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for NewShortArray*/
static jshortArray JNICALL bda_c2j_proxy_NewShortArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jshortArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewShortArray++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewShortArray++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewShortArray")
    && bda_check_no_exeception(s, "NewShortArray")
    && bda_check_capacity_c2j_call(s, "NewShortArray")
    && bda_check_no_critical(s, "NewShortArray")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewShortArray;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewShortArray", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %d(jsize)\n", "NewShortArray" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewShortArray(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewShortArray", s->name)) {
    printf("<= %-50s %p\n", "NewShortArray", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for NewIntArray*/
static jintArray JNICALL bda_c2j_proxy_NewIntArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jintArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewIntArray++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewIntArray++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewIntArray")
    && bda_check_no_exeception(s, "NewIntArray")
    && bda_check_capacity_c2j_call(s, "NewIntArray")
    && bda_check_no_critical(s, "NewIntArray")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewIntArray;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewIntArray", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %d(jsize)\n", "NewIntArray" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewIntArray(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewIntArray", s->name)) {
    printf("<= %-50s %p\n", "NewIntArray", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for NewLongArray*/
static jlongArray JNICALL bda_c2j_proxy_NewLongArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jlongArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewLongArray++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewLongArray++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewLongArray")
    && bda_check_no_exeception(s, "NewLongArray")
    && bda_check_capacity_c2j_call(s, "NewLongArray")
    && bda_check_no_critical(s, "NewLongArray")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewLongArray;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewLongArray", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %d(jsize)\n", "NewLongArray" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewLongArray(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewLongArray", s->name)) {
    printf("<= %-50s %p\n", "NewLongArray", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for NewFloatArray*/
static jfloatArray JNICALL bda_c2j_proxy_NewFloatArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jfloatArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewFloatArray++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewFloatArray++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewFloatArray")
    && bda_check_no_exeception(s, "NewFloatArray")
    && bda_check_capacity_c2j_call(s, "NewFloatArray")
    && bda_check_no_critical(s, "NewFloatArray")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewFloatArray;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewFloatArray", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %d(jsize)\n", "NewFloatArray" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewFloatArray(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewFloatArray", s->name)) {
    printf("<= %-50s %p\n", "NewFloatArray", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for NewDoubleArray*/
static jdoubleArray JNICALL bda_c2j_proxy_NewDoubleArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jdoubleArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewDoubleArray++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewDoubleArray++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewDoubleArray")
    && bda_check_no_exeception(s, "NewDoubleArray")
    && bda_check_capacity_c2j_call(s, "NewDoubleArray")
    && bda_check_no_critical(s, "NewDoubleArray")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewDoubleArray;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewDoubleArray", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %d(jsize)\n", "NewDoubleArray" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewDoubleArray(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewDoubleArray", s->name)) {
    printf("<= %-50s %p\n", "NewDoubleArray", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for GetBooleanArrayElements*/
static jboolean * JNICALL bda_c2j_proxy_GetBooleanArrayElements(JNIEnv * env, jbooleanArray p1, jboolean * p2)
{
  /* local variables */
  jboolean * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetBooleanArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetBooleanArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetBooleanArrayElements")
    && bda_check_no_exeception(s, "GetBooleanArrayElements")
    && bda_check_no_critical(s, "GetBooleanArrayElements")
    && bda_check_non_null(s, p1,  1, "GetBooleanArrayElements")
    && bda_check_dref(s, p1, 1, "GetBooleanArrayElements")
    && bda_check_jbooleanArray(s, p1, 1, "GetBooleanArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetBooleanArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetBooleanArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jbooleanArray) %p(jboolean *)\n", "GetBooleanArrayElements" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetBooleanArrayElements(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetBooleanArrayElements", s->name)) {
    printf("<= %-50s %p\n", "GetBooleanArrayElements", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetBooleanArrayElements");}
  }

  return result;
}


/* proxy for GetByteArrayElements*/
static jbyte * JNICALL bda_c2j_proxy_GetByteArrayElements(JNIEnv * env, jbyteArray p1, jboolean * p2)
{
  /* local variables */
  jbyte * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetByteArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetByteArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetByteArrayElements")
    && bda_check_no_exeception(s, "GetByteArrayElements")
    && bda_check_no_critical(s, "GetByteArrayElements")
    && bda_check_non_null(s, p1,  1, "GetByteArrayElements")
    && bda_check_dref(s, p1, 1, "GetByteArrayElements")
    && bda_check_jbyteArray(s, p1, 1, "GetByteArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetByteArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetByteArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jbyteArray) %p(jboolean *)\n", "GetByteArrayElements" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetByteArrayElements(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetByteArrayElements", s->name)) {
    printf("<= %-50s %p\n", "GetByteArrayElements", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetByteArrayElements");}
  }

  return result;
}


/* proxy for GetCharArrayElements*/
static jchar * JNICALL bda_c2j_proxy_GetCharArrayElements(JNIEnv * env, jcharArray p1, jboolean * p2)
{
  /* local variables */
  jchar * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetCharArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetCharArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetCharArrayElements")
    && bda_check_no_exeception(s, "GetCharArrayElements")
    && bda_check_no_critical(s, "GetCharArrayElements")
    && bda_check_non_null(s, p1,  1, "GetCharArrayElements")
    && bda_check_dref(s, p1, 1, "GetCharArrayElements")
    && bda_check_jcharArray(s, p1, 1, "GetCharArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetCharArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetCharArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jcharArray) %p(jboolean *)\n", "GetCharArrayElements" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetCharArrayElements(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetCharArrayElements", s->name)) {
    printf("<= %-50s %p\n", "GetCharArrayElements", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetCharArrayElements");}
  }

  return result;
}


/* proxy for GetShortArrayElements*/
static jshort * JNICALL bda_c2j_proxy_GetShortArrayElements(JNIEnv * env, jshortArray p1, jboolean * p2)
{
  /* local variables */
  jshort * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetShortArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetShortArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetShortArrayElements")
    && bda_check_no_exeception(s, "GetShortArrayElements")
    && bda_check_no_critical(s, "GetShortArrayElements")
    && bda_check_non_null(s, p1,  1, "GetShortArrayElements")
    && bda_check_dref(s, p1, 1, "GetShortArrayElements")
    && bda_check_jshortArray(s, p1, 1, "GetShortArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetShortArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetShortArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jshortArray) %p(jboolean *)\n", "GetShortArrayElements" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetShortArrayElements(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetShortArrayElements", s->name)) {
    printf("<= %-50s %p\n", "GetShortArrayElements", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetShortArrayElements");}
  }

  return result;
}


/* proxy for GetIntArrayElements*/
static jint * JNICALL bda_c2j_proxy_GetIntArrayElements(JNIEnv * env, jintArray p1, jboolean * p2)
{
  /* local variables */
  jint * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetIntArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetIntArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetIntArrayElements")
    && bda_check_no_exeception(s, "GetIntArrayElements")
    && bda_check_no_critical(s, "GetIntArrayElements")
    && bda_check_non_null(s, p1,  1, "GetIntArrayElements")
    && bda_check_dref(s, p1, 1, "GetIntArrayElements")
    && bda_check_jintArray(s, p1, 1, "GetIntArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetIntArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetIntArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jintArray) %p(jboolean *)\n", "GetIntArrayElements" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetIntArrayElements(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetIntArrayElements", s->name)) {
    printf("<= %-50s %p\n", "GetIntArrayElements", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetIntArrayElements");}
  }

  return result;
}


/* proxy for GetLongArrayElements*/
static jlong * JNICALL bda_c2j_proxy_GetLongArrayElements(JNIEnv * env, jlongArray p1, jboolean * p2)
{
  /* local variables */
  jlong * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetLongArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetLongArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetLongArrayElements")
    && bda_check_no_exeception(s, "GetLongArrayElements")
    && bda_check_no_critical(s, "GetLongArrayElements")
    && bda_check_non_null(s, p1,  1, "GetLongArrayElements")
    && bda_check_dref(s, p1, 1, "GetLongArrayElements")
    && bda_check_jlongArray(s, p1, 1, "GetLongArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetLongArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetLongArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jlongArray) %p(jboolean *)\n", "GetLongArrayElements" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetLongArrayElements(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetLongArrayElements", s->name)) {
    printf("<= %-50s %p\n", "GetLongArrayElements", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetLongArrayElements");}
  }

  return result;
}


/* proxy for GetFloatArrayElements*/
static jfloat * JNICALL bda_c2j_proxy_GetFloatArrayElements(JNIEnv * env, jfloatArray p1, jboolean * p2)
{
  /* local variables */
  jfloat * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetFloatArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetFloatArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetFloatArrayElements")
    && bda_check_no_exeception(s, "GetFloatArrayElements")
    && bda_check_no_critical(s, "GetFloatArrayElements")
    && bda_check_non_null(s, p1,  1, "GetFloatArrayElements")
    && bda_check_dref(s, p1, 1, "GetFloatArrayElements")
    && bda_check_jfloatArray(s, p1, 1, "GetFloatArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetFloatArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetFloatArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jfloatArray) %p(jboolean *)\n", "GetFloatArrayElements" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetFloatArrayElements(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetFloatArrayElements", s->name)) {
    printf("<= %-50s %p\n", "GetFloatArrayElements", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetFloatArrayElements");}
  }

  return result;
}


/* proxy for GetDoubleArrayElements*/
static jdouble * JNICALL bda_c2j_proxy_GetDoubleArrayElements(JNIEnv * env, jdoubleArray p1, jboolean * p2)
{
  /* local variables */
  jdouble * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetDoubleArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetDoubleArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDoubleArrayElements")
    && bda_check_no_exeception(s, "GetDoubleArrayElements")
    && bda_check_no_critical(s, "GetDoubleArrayElements")
    && bda_check_non_null(s, p1,  1, "GetDoubleArrayElements")
    && bda_check_dref(s, p1, 1, "GetDoubleArrayElements")
    && bda_check_jdoubleArray(s, p1, 1, "GetDoubleArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDoubleArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetDoubleArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jdoubleArray) %p(jboolean *)\n", "GetDoubleArrayElements" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetDoubleArrayElements(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetDoubleArrayElements", s->name)) {
    printf("<= %-50s %p\n", "GetDoubleArrayElements", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetDoubleArrayElements");}
  }

  return result;
}


/* proxy for ReleaseBooleanArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseBooleanArrayElements(JNIEnv * env, jbooleanArray p1, jboolean * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ReleaseBooleanArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseBooleanArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseBooleanArrayElements")
    && bda_check_no_critical(s, "ReleaseBooleanArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseBooleanArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseBooleanArrayElements")
    && bda_check_resource_free(s, p2, "ReleaseBooleanArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseBooleanArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseBooleanArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jbooleanArray) %p(jboolean *) %d(jint)\n", "ReleaseBooleanArrayElements" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseBooleanArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseBooleanArrayElements", s->name)) {
    printf("<= %-50s\n", "ReleaseBooleanArrayElements");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseBooleanArrayElements");}
  }

}


/* proxy for ReleaseByteArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseByteArrayElements(JNIEnv * env, jbyteArray p1, jbyte * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ReleaseByteArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseByteArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseByteArrayElements")
    && bda_check_no_critical(s, "ReleaseByteArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseByteArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseByteArrayElements")
    && bda_check_resource_free(s, p2, "ReleaseByteArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseByteArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseByteArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jbyteArray) %p(jbyte *) %d(jint)\n", "ReleaseByteArrayElements" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseByteArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseByteArrayElements", s->name)) {
    printf("<= %-50s\n", "ReleaseByteArrayElements");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseByteArrayElements");}
  }

}


/* proxy for ReleaseCharArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseCharArrayElements(JNIEnv * env, jcharArray p1, jchar * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ReleaseCharArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseCharArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseCharArrayElements")
    && bda_check_no_critical(s, "ReleaseCharArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseCharArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseCharArrayElements")
    && bda_check_resource_free(s, p2, "ReleaseCharArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseCharArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseCharArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jcharArray) %p(jchar *) %d(jint)\n", "ReleaseCharArrayElements" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseCharArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseCharArrayElements", s->name)) {
    printf("<= %-50s\n", "ReleaseCharArrayElements");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseCharArrayElements");}
  }

}


/* proxy for ReleaseShortArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseShortArrayElements(JNIEnv * env, jshortArray p1, jshort * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ReleaseShortArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseShortArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseShortArrayElements")
    && bda_check_no_critical(s, "ReleaseShortArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseShortArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseShortArrayElements")
    && bda_check_resource_free(s, p2, "ReleaseShortArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseShortArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseShortArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jshortArray) %p(jshort *) %d(jint)\n", "ReleaseShortArrayElements" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseShortArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseShortArrayElements", s->name)) {
    printf("<= %-50s\n", "ReleaseShortArrayElements");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseShortArrayElements");}
  }

}


/* proxy for ReleaseIntArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseIntArrayElements(JNIEnv * env, jintArray p1, jint * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ReleaseIntArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseIntArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseIntArrayElements")
    && bda_check_no_critical(s, "ReleaseIntArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseIntArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseIntArrayElements")
    && bda_check_resource_free(s, p2, "ReleaseIntArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseIntArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseIntArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jintArray) %p(jint *) %d(jint)\n", "ReleaseIntArrayElements" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseIntArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseIntArrayElements", s->name)) {
    printf("<= %-50s\n", "ReleaseIntArrayElements");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseIntArrayElements");}
  }

}


/* proxy for ReleaseLongArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseLongArrayElements(JNIEnv * env, jlongArray p1, jlong * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ReleaseLongArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseLongArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseLongArrayElements")
    && bda_check_no_critical(s, "ReleaseLongArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseLongArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseLongArrayElements")
    && bda_check_resource_free(s, p2, "ReleaseLongArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseLongArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseLongArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jlongArray) %p(jlong *) %d(jint)\n", "ReleaseLongArrayElements" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseLongArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseLongArrayElements", s->name)) {
    printf("<= %-50s\n", "ReleaseLongArrayElements");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseLongArrayElements");}
  }

}


/* proxy for ReleaseFloatArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseFloatArrayElements(JNIEnv * env, jfloatArray p1, jfloat * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ReleaseFloatArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseFloatArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseFloatArrayElements")
    && bda_check_no_critical(s, "ReleaseFloatArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseFloatArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseFloatArrayElements")
    && bda_check_resource_free(s, p2, "ReleaseFloatArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseFloatArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseFloatArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jfloatArray) %p(jfloat *) %d(jint)\n", "ReleaseFloatArrayElements" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseFloatArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseFloatArrayElements", s->name)) {
    printf("<= %-50s\n", "ReleaseFloatArrayElements");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseFloatArrayElements");}
  }

}


/* proxy for ReleaseDoubleArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseDoubleArrayElements(JNIEnv * env, jdoubleArray p1, jdouble * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ReleaseDoubleArrayElements++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseDoubleArrayElements++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseDoubleArrayElements")
    && bda_check_no_critical(s, "ReleaseDoubleArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseDoubleArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseDoubleArrayElements")
    && bda_check_resource_free(s, p2, "ReleaseDoubleArrayElements")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseDoubleArrayElements;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseDoubleArrayElements", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jdoubleArray) %p(jdouble *) %d(jint)\n", "ReleaseDoubleArrayElements" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseDoubleArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseDoubleArrayElements", s->name)) {
    printf("<= %-50s\n", "ReleaseDoubleArrayElements");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseDoubleArrayElements");}
  }

}


/* proxy for GetBooleanArrayRegion*/
static void JNICALL bda_c2j_proxy_GetBooleanArrayRegion(JNIEnv * env, jbooleanArray p1, jsize p2, jsize p3, jboolean * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetBooleanArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetBooleanArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetBooleanArrayRegion")
    && bda_check_no_exeception(s, "GetBooleanArrayRegion")
    && bda_check_no_critical(s, "GetBooleanArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetBooleanArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetBooleanArrayRegion")
    && bda_check_dref(s, p1, 1, "GetBooleanArrayRegion")
    && bda_check_jbooleanArray(s, p1, 1, "GetBooleanArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetBooleanArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetBooleanArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jbooleanArray) %d(jsize) %d(jsize) %p(jboolean *)\n", "GetBooleanArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetBooleanArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetBooleanArrayRegion", s->name)) {
    printf("<= %-50s\n", "GetBooleanArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for GetByteArrayRegion*/
static void JNICALL bda_c2j_proxy_GetByteArrayRegion(JNIEnv * env, jbyteArray p1, jsize p2, jsize p3, jbyte * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetByteArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetByteArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetByteArrayRegion")
    && bda_check_no_exeception(s, "GetByteArrayRegion")
    && bda_check_no_critical(s, "GetByteArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetByteArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetByteArrayRegion")
    && bda_check_dref(s, p1, 1, "GetByteArrayRegion")
    && bda_check_jbyteArray(s, p1, 1, "GetByteArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetByteArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetByteArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jbyteArray) %d(jsize) %d(jsize) %p(jbyte *)\n", "GetByteArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetByteArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetByteArrayRegion", s->name)) {
    printf("<= %-50s\n", "GetByteArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for GetCharArrayRegion*/
static void JNICALL bda_c2j_proxy_GetCharArrayRegion(JNIEnv * env, jcharArray p1, jsize p2, jsize p3, jchar * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetCharArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetCharArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetCharArrayRegion")
    && bda_check_no_exeception(s, "GetCharArrayRegion")
    && bda_check_no_critical(s, "GetCharArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetCharArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetCharArrayRegion")
    && bda_check_dref(s, p1, 1, "GetCharArrayRegion")
    && bda_check_jcharArray(s, p1, 1, "GetCharArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetCharArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetCharArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jcharArray) %d(jsize) %d(jsize) %p(jchar *)\n", "GetCharArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetCharArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetCharArrayRegion", s->name)) {
    printf("<= %-50s\n", "GetCharArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for GetShortArrayRegion*/
static void JNICALL bda_c2j_proxy_GetShortArrayRegion(JNIEnv * env, jshortArray p1, jsize p2, jsize p3, jshort * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetShortArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetShortArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetShortArrayRegion")
    && bda_check_no_exeception(s, "GetShortArrayRegion")
    && bda_check_no_critical(s, "GetShortArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetShortArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetShortArrayRegion")
    && bda_check_dref(s, p1, 1, "GetShortArrayRegion")
    && bda_check_jshortArray(s, p1, 1, "GetShortArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetShortArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetShortArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jshortArray) %d(jsize) %d(jsize) %p(jshort *)\n", "GetShortArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetShortArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetShortArrayRegion", s->name)) {
    printf("<= %-50s\n", "GetShortArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for GetIntArrayRegion*/
static void JNICALL bda_c2j_proxy_GetIntArrayRegion(JNIEnv * env, jintArray p1, jsize p2, jsize p3, jint * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetIntArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetIntArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetIntArrayRegion")
    && bda_check_no_exeception(s, "GetIntArrayRegion")
    && bda_check_no_critical(s, "GetIntArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetIntArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetIntArrayRegion")
    && bda_check_dref(s, p1, 1, "GetIntArrayRegion")
    && bda_check_jintArray(s, p1, 1, "GetIntArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetIntArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetIntArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jintArray) %d(jsize) %d(jsize) %p(jint *)\n", "GetIntArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetIntArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetIntArrayRegion", s->name)) {
    printf("<= %-50s\n", "GetIntArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for GetLongArrayRegion*/
static void JNICALL bda_c2j_proxy_GetLongArrayRegion(JNIEnv * env, jlongArray p1, jsize p2, jsize p3, jlong * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetLongArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetLongArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetLongArrayRegion")
    && bda_check_no_exeception(s, "GetLongArrayRegion")
    && bda_check_no_critical(s, "GetLongArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetLongArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetLongArrayRegion")
    && bda_check_dref(s, p1, 1, "GetLongArrayRegion")
    && bda_check_jlongArray(s, p1, 1, "GetLongArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetLongArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetLongArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jlongArray) %d(jsize) %d(jsize) %p(jlong *)\n", "GetLongArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetLongArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetLongArrayRegion", s->name)) {
    printf("<= %-50s\n", "GetLongArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for GetFloatArrayRegion*/
static void JNICALL bda_c2j_proxy_GetFloatArrayRegion(JNIEnv * env, jfloatArray p1, jsize p2, jsize p3, jfloat * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetFloatArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetFloatArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetFloatArrayRegion")
    && bda_check_no_exeception(s, "GetFloatArrayRegion")
    && bda_check_no_critical(s, "GetFloatArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetFloatArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetFloatArrayRegion")
    && bda_check_dref(s, p1, 1, "GetFloatArrayRegion")
    && bda_check_jfloatArray(s, p1, 1, "GetFloatArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetFloatArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetFloatArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jfloatArray) %d(jsize) %d(jsize) %p(jfloat *)\n", "GetFloatArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetFloatArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetFloatArrayRegion", s->name)) {
    printf("<= %-50s\n", "GetFloatArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for GetDoubleArrayRegion*/
static void JNICALL bda_c2j_proxy_GetDoubleArrayRegion(JNIEnv * env, jdoubleArray p1, jsize p2, jsize p3, jdouble * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetDoubleArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetDoubleArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDoubleArrayRegion")
    && bda_check_no_exeception(s, "GetDoubleArrayRegion")
    && bda_check_no_critical(s, "GetDoubleArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetDoubleArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetDoubleArrayRegion")
    && bda_check_dref(s, p1, 1, "GetDoubleArrayRegion")
    && bda_check_jdoubleArray(s, p1, 1, "GetDoubleArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDoubleArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetDoubleArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jdoubleArray) %d(jsize) %d(jsize) %p(jdouble *)\n", "GetDoubleArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetDoubleArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetDoubleArrayRegion", s->name)) {
    printf("<= %-50s\n", "GetDoubleArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetBooleanArrayRegion*/
static void JNICALL bda_c2j_proxy_SetBooleanArrayRegion(JNIEnv * env, jbooleanArray p1, jsize p2, jsize p3, const jboolean * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetBooleanArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetBooleanArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetBooleanArrayRegion")
    && bda_check_no_exeception(s, "SetBooleanArrayRegion")
    && bda_check_no_critical(s, "SetBooleanArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetBooleanArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetBooleanArrayRegion")
    && bda_check_dref(s, p1, 1, "SetBooleanArrayRegion")
    && bda_check_jbooleanArray(s, p1, 1, "SetBooleanArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetBooleanArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetBooleanArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jbooleanArray) %d(jsize) %d(jsize) %p(const jboolean *)\n", "SetBooleanArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetBooleanArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetBooleanArrayRegion", s->name)) {
    printf("<= %-50s\n", "SetBooleanArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetByteArrayRegion*/
static void JNICALL bda_c2j_proxy_SetByteArrayRegion(JNIEnv * env, jbyteArray p1, jsize p2, jsize p3, const jbyte * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetByteArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetByteArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetByteArrayRegion")
    && bda_check_no_exeception(s, "SetByteArrayRegion")
    && bda_check_no_critical(s, "SetByteArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetByteArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetByteArrayRegion")
    && bda_check_dref(s, p1, 1, "SetByteArrayRegion")
    && bda_check_jbyteArray(s, p1, 1, "SetByteArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetByteArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetByteArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jbyteArray) %d(jsize) %d(jsize) %s(const jbyte *)\n", "SetByteArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetByteArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetByteArrayRegion", s->name)) {
    printf("<= %-50s\n", "SetByteArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetCharArrayRegion*/
static void JNICALL bda_c2j_proxy_SetCharArrayRegion(JNIEnv * env, jcharArray p1, jsize p2, jsize p3, const jchar * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetCharArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetCharArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetCharArrayRegion")
    && bda_check_no_exeception(s, "SetCharArrayRegion")
    && bda_check_no_critical(s, "SetCharArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetCharArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetCharArrayRegion")
    && bda_check_dref(s, p1, 1, "SetCharArrayRegion")
    && bda_check_jcharArray(s, p1, 1, "SetCharArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetCharArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetCharArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jcharArray) %d(jsize) %d(jsize) %p(const jchar *)\n", "SetCharArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetCharArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetCharArrayRegion", s->name)) {
    printf("<= %-50s\n", "SetCharArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetShortArrayRegion*/
static void JNICALL bda_c2j_proxy_SetShortArrayRegion(JNIEnv * env, jshortArray p1, jsize p2, jsize p3, const jshort * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetShortArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetShortArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetShortArrayRegion")
    && bda_check_no_exeception(s, "SetShortArrayRegion")
    && bda_check_no_critical(s, "SetShortArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetShortArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetShortArrayRegion")
    && bda_check_dref(s, p1, 1, "SetShortArrayRegion")
    && bda_check_jshortArray(s, p1, 1, "SetShortArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetShortArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetShortArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jshortArray) %d(jsize) %d(jsize) %p(const jshort *)\n", "SetShortArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetShortArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetShortArrayRegion", s->name)) {
    printf("<= %-50s\n", "SetShortArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetIntArrayRegion*/
static void JNICALL bda_c2j_proxy_SetIntArrayRegion(JNIEnv * env, jintArray p1, jsize p2, jsize p3, const jint * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetIntArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetIntArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetIntArrayRegion")
    && bda_check_no_exeception(s, "SetIntArrayRegion")
    && bda_check_no_critical(s, "SetIntArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetIntArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetIntArrayRegion")
    && bda_check_dref(s, p1, 1, "SetIntArrayRegion")
    && bda_check_jintArray(s, p1, 1, "SetIntArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetIntArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetIntArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jintArray) %d(jsize) %d(jsize) %p(const jint *)\n", "SetIntArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetIntArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetIntArrayRegion", s->name)) {
    printf("<= %-50s\n", "SetIntArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetLongArrayRegion*/
static void JNICALL bda_c2j_proxy_SetLongArrayRegion(JNIEnv * env, jlongArray p1, jsize p2, jsize p3, const jlong * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetLongArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetLongArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetLongArrayRegion")
    && bda_check_no_exeception(s, "SetLongArrayRegion")
    && bda_check_no_critical(s, "SetLongArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetLongArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetLongArrayRegion")
    && bda_check_dref(s, p1, 1, "SetLongArrayRegion")
    && bda_check_jlongArray(s, p1, 1, "SetLongArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetLongArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetLongArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jlongArray) %d(jsize) %d(jsize) %p(const jlong *)\n", "SetLongArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetLongArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetLongArrayRegion", s->name)) {
    printf("<= %-50s\n", "SetLongArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetFloatArrayRegion*/
static void JNICALL bda_c2j_proxy_SetFloatArrayRegion(JNIEnv * env, jfloatArray p1, jsize p2, jsize p3, const jfloat * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetFloatArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetFloatArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetFloatArrayRegion")
    && bda_check_no_exeception(s, "SetFloatArrayRegion")
    && bda_check_no_critical(s, "SetFloatArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetFloatArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetFloatArrayRegion")
    && bda_check_dref(s, p1, 1, "SetFloatArrayRegion")
    && bda_check_jfloatArray(s, p1, 1, "SetFloatArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetFloatArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetFloatArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jfloatArray) %d(jsize) %d(jsize) %p(const jfloat *)\n", "SetFloatArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetFloatArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetFloatArrayRegion", s->name)) {
    printf("<= %-50s\n", "SetFloatArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for SetDoubleArrayRegion*/
static void JNICALL bda_c2j_proxy_SetDoubleArrayRegion(JNIEnv * env, jdoubleArray p1, jsize p2, jsize p3, const jdouble * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.SetDoubleArrayRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetDoubleArrayRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetDoubleArrayRegion")
    && bda_check_no_exeception(s, "SetDoubleArrayRegion")
    && bda_check_no_critical(s, "SetDoubleArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetDoubleArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetDoubleArrayRegion")
    && bda_check_dref(s, p1, 1, "SetDoubleArrayRegion")
    && bda_check_jdoubleArray(s, p1, 1, "SetDoubleArrayRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetDoubleArrayRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("SetDoubleArrayRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jdoubleArray) %d(jsize) %d(jsize) %p(const jdouble *)\n", "SetDoubleArrayRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetDoubleArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("SetDoubleArrayRegion", s->name)) {
    printf("<= %-50s\n", "SetDoubleArrayRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for RegisterNatives*/
static jint JNICALL bda_c2j_proxy_RegisterNatives(JNIEnv * env, jclass p1, const JNINativeMethod * p2, jint p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.RegisterNatives++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.RegisterNatives++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "RegisterNatives")
    && bda_check_no_exeception(s, "RegisterNatives")
    && bda_check_no_critical(s, "RegisterNatives")
    && bda_check_non_null(s, p1,  1, "RegisterNatives")
    && bda_check_non_null(s, p2,  2, "RegisterNatives")
    && bda_check_dref(s, p1, 1, "RegisterNatives")
    && bda_check_jclass(s, p1, 1, "RegisterNatives")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_RegisterNatives;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("RegisterNatives", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass) %p(const JNINativeMethod *) %d(jint)\n", "RegisterNatives" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->RegisterNatives(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("RegisterNatives", s->name)) {
    printf("<= %-50s %d\n", "RegisterNatives", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for UnregisterNatives*/
static jint JNICALL bda_c2j_proxy_UnregisterNatives(JNIEnv * env, jclass p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.UnregisterNatives++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.UnregisterNatives++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "UnregisterNatives")
    && bda_check_no_exeception(s, "UnregisterNatives")
    && bda_check_no_critical(s, "UnregisterNatives")
    && bda_check_non_null(s, p1,  1, "UnregisterNatives")
    && bda_check_dref(s, p1, 1, "UnregisterNatives")
    && bda_check_jclass(s, p1, 1, "UnregisterNatives")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_UnregisterNatives;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("UnregisterNatives", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jclass)\n", "UnregisterNatives" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->UnregisterNatives(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("UnregisterNatives", s->name)) {
    printf("<= %-50s %d\n", "UnregisterNatives", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for MonitorEnter*/
static jint JNICALL bda_c2j_proxy_MonitorEnter(JNIEnv * env, jobject p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.MonitorEnter++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.MonitorEnter++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "MonitorEnter")
    && bda_check_no_exeception(s, "MonitorEnter")
    && bda_check_no_critical(s, "MonitorEnter")
    && bda_check_non_null(s, p1,  1, "MonitorEnter")
    && bda_check_dref(s, p1, 1, "MonitorEnter")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_MonitorEnter;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("MonitorEnter", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "MonitorEnter" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->MonitorEnter(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("MonitorEnter", s->name)) {
    printf("<= %-50s %d\n", "MonitorEnter", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for MonitorExit*/
static jint JNICALL bda_c2j_proxy_MonitorExit(JNIEnv * env, jobject p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.MonitorExit++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.MonitorExit++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "MonitorExit")
    && bda_check_no_critical(s, "MonitorExit")
    && bda_check_non_null(s, p1,  1, "MonitorExit")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_MonitorExit;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("MonitorExit", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "MonitorExit" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->MonitorExit(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("MonitorExit", s->name)) {
    printf("<= %-50s %d\n", "MonitorExit", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetJavaVM*/
static jint JNICALL bda_c2j_proxy_GetJavaVM(JNIEnv * env, JavaVM ** p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetJavaVM++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetJavaVM++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetJavaVM")
    && bda_check_no_exeception(s, "GetJavaVM")
    && bda_check_no_critical(s, "GetJavaVM")
    && bda_check_non_null(s, p1,  1, "GetJavaVM")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetJavaVM;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetJavaVM", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(JavaVM **)\n", "GetJavaVM" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetJavaVM(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetJavaVM", s->name)) {
    printf("<= %-50s %d\n", "GetJavaVM", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStringRegion*/
static void JNICALL bda_c2j_proxy_GetStringRegion(JNIEnv * env, jstring p1, jsize p2, jsize p3, jchar * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStringRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringRegion")
    && bda_check_no_exeception(s, "GetStringRegion")
    && bda_check_no_critical(s, "GetStringRegion")
    && bda_check_non_null(s, p1,  1, "GetStringRegion")
    && bda_check_non_null(s, p4,  4, "GetStringRegion")
    && bda_check_dref(s, p1, 1, "GetStringRegion")
    && bda_check_jstring(s, p1, 1, "GetStringRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jstring) %d(jsize) %d(jsize) %p(jchar *)\n", "GetStringRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetStringRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringRegion", s->name)) {
    printf("<= %-50s\n", "GetStringRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for GetStringUTFRegion*/
static void JNICALL bda_c2j_proxy_GetStringUTFRegion(JNIEnv * env, jstring p1, jsize p2, jsize p3, char * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStringUTFRegion++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringUTFRegion++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringUTFRegion")
    && bda_check_no_exeception(s, "GetStringUTFRegion")
    && bda_check_no_critical(s, "GetStringUTFRegion")
    && bda_check_non_null(s, p1,  1, "GetStringUTFRegion")
    && bda_check_non_null(s, p4,  4, "GetStringUTFRegion")
    && bda_check_dref(s, p1, 1, "GetStringUTFRegion")
    && bda_check_jstring(s, p1, 1, "GetStringUTFRegion")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringUTFRegion;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringUTFRegion", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jstring) %d(jsize) %d(jsize) %s(char *)\n", "GetStringUTFRegion" , env, p1, p2, p3, p4);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetStringUTFRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringUTFRegion", s->name)) {
    printf("<= %-50s\n", "GetStringUTFRegion");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

}


/* proxy for GetPrimitiveArrayCritical*/
static void * JNICALL bda_c2j_proxy_GetPrimitiveArrayCritical(JNIEnv * env, jarray p1, jboolean * p2)
{
  /* local variables */
  void * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetPrimitiveArrayCritical++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetPrimitiveArrayCritical++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetPrimitiveArrayCritical")
    && bda_check_no_exeception(s, "GetPrimitiveArrayCritical")
    && bda_check_non_null(s, p1,  1, "GetPrimitiveArrayCritical")
    && bda_check_dref(s, p1, 1, "GetPrimitiveArrayCritical")
    && bda_check_jarray(s, p1, 1, "GetPrimitiveArrayCritical")
    ;
    bda_enter_critical(s);
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetPrimitiveArrayCritical;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetPrimitiveArrayCritical", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jarray) %p(jboolean *)\n", "GetPrimitiveArrayCritical" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetPrimitiveArrayCritical(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetPrimitiveArrayCritical", s->name)) {
    printf("<= %-50s %p\n", "GetPrimitiveArrayCritical", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetPrimitiveArrayCritical");}
  }

  return result;
}


/* proxy for ReleasePrimitiveArrayCritical*/
static void JNICALL bda_c2j_proxy_ReleasePrimitiveArrayCritical(JNIEnv * env, jarray p1, void * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_state_find(env);

  /* Update call counts. */
  bda_c2j_count.ReleasePrimitiveArrayCritical++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleasePrimitiveArrayCritical++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleasePrimitiveArrayCritical")
    && bda_check_non_null(s, p1,  1, "ReleasePrimitiveArrayCritical")
    && bda_check_non_null(s, p2,  2, "ReleasePrimitiveArrayCritical")
    && bda_check_resource_free(s, p2, "ReleasePrimitiveArrayCritical")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleasePrimitiveArrayCritical;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ReleasePrimitiveArrayCritical", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jarray) %p(void *) %d(jint)\n", "ReleasePrimitiveArrayCritical" , env, p1, p2, p3);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleasePrimitiveArrayCritical(env, p1, p2, p3);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ReleasePrimitiveArrayCritical", s->name)) {
    printf("<= %-50s\n", "ReleasePrimitiveArrayCritical");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    bda_leave_critical(s);
    bda_resource_release(s, p2, "ReleasePrimitiveArrayCritical");
  }

}


/* proxy for GetStringCritical*/
static const jchar * JNICALL bda_c2j_proxy_GetStringCritical(JNIEnv * env, jstring p1, jboolean * p2)
{
  /* local variables */
  const jchar * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetStringCritical++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringCritical++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringCritical")
    && bda_check_no_exeception(s, "GetStringCritical")
    && bda_check_non_null(s, p1,  1, "GetStringCritical")
    && bda_check_dref(s, p1, 1, "GetStringCritical")
    && bda_check_jstring(s, p1, 1, "GetStringCritical")
    ;
    bda_enter_critical(s);
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringCritical;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringCritical", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jstring) %p(jboolean *)\n", "GetStringCritical" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringCritical(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetStringCritical", s->name)) {
    printf("<= %-50s %p\n", "GetStringCritical", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetStringCritical");}
  }

  return result;
}


/* proxy for ReleaseStringCritical*/
static void JNICALL bda_c2j_proxy_ReleaseStringCritical(JNIEnv * env, jstring p1, const jchar * p2)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_state_find(env);

  /* Update call counts. */
  bda_c2j_count.ReleaseStringCritical++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseStringCritical++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseStringCritical")
    && bda_check_non_null(s, p1,  1, "ReleaseStringCritical")
    && bda_check_non_null(s, p2,  2, "ReleaseStringCritical")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseStringCritical;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseStringCritical", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jstring) %p(const jchar *)\n", "ReleaseStringCritical" , env, p1, p2);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseStringCritical(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ReleaseStringCritical", s->name)) {
    printf("<= %-50s\n", "ReleaseStringCritical");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    bda_leave_critical(s);
    bda_resource_release(s, p2, "ReleaseStringCritical");
  }

}


/* proxy for NewWeakGlobalRef*/
static jweak JNICALL bda_c2j_proxy_NewWeakGlobalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  jweak result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewWeakGlobalRef++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewWeakGlobalRef++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewWeakGlobalRef")
    && bda_check_no_exeception(s, "NewWeakGlobalRef")
    && bda_check_capacity_c2j_call(s, "NewWeakGlobalRef")
    && bda_check_no_critical(s, "NewWeakGlobalRef")
    && bda_check_non_null(s, p1,  1, "NewWeakGlobalRef")
    && bda_check_dref(s, p1, 1, "NewWeakGlobalRef")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewWeakGlobalRef;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewWeakGlobalRef", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "NewWeakGlobalRef" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewWeakGlobalRef(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewWeakGlobalRef", s->name)) {
    printf("<= %-50s %p\n", "NewWeakGlobalRef", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      bda_global_ref_add(result, 1);
    }
  }

  return result;
}


/* proxy for DeleteWeakGlobalRef*/
static void JNICALL bda_c2j_proxy_DeleteWeakGlobalRef(JNIEnv * env, jweak p1)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.DeleteWeakGlobalRef++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.DeleteWeakGlobalRef++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "DeleteWeakGlobalRef")
    && bda_check_no_critical(s, "DeleteWeakGlobalRef")
    && bda_check_jobject_ref_type(s, p1, JNIWeakGlobalRefType , 1, "DeleteWeakGlobalRef")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_DeleteWeakGlobalRef;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("DeleteWeakGlobalRef", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jweak)\n", "DeleteWeakGlobalRef" , env, p1);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->DeleteWeakGlobalRef(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("DeleteWeakGlobalRef", s->name)) {
    printf("<= %-50s\n", "DeleteWeakGlobalRef");
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
   bda_global_ref_delete(p1, 1);
  }

}


/* proxy for ExceptionCheck*/
static jboolean JNICALL bda_c2j_proxy_ExceptionCheck(JNIEnv * env)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.ExceptionCheck++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ExceptionCheck++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ExceptionCheck")
    && bda_check_no_critical(s, "ExceptionCheck")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ExceptionCheck;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("ExceptionCheck", s->name)) {
    printf("=> %-50s %p(JNIEnv *)\n", "ExceptionCheck" , env);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ExceptionCheck(env);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("ExceptionCheck", s->name)) {
    printf("<= %-50s %d\n", "ExceptionCheck", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for NewDirectByteBuffer*/
static jobject JNICALL bda_c2j_proxy_NewDirectByteBuffer(JNIEnv * env, void * p1, jlong p2)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.NewDirectByteBuffer++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewDirectByteBuffer++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewDirectByteBuffer")
    && bda_check_no_exeception(s, "NewDirectByteBuffer")
    && bda_check_capacity_c2j_call(s, "NewDirectByteBuffer")
    && bda_check_no_critical(s, "NewDirectByteBuffer")
    && bda_check_non_null(s, p1,  1, "NewDirectByteBuffer")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewDirectByteBuffer;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("NewDirectByteBuffer", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(void *) %lld(jlong)\n", "NewDirectByteBuffer" , env, p1, p2);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewDirectByteBuffer(env, p1, p2);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("NewDirectByteBuffer", s->name)) {
    printf("<= %-50s %p\n", "NewDirectByteBuffer", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
    if (result != NULL) {
      if (result != NULL) {bda_local_ref_add(s, result);}
    }
  }

  return result;
}


/* proxy for GetDirectBufferAddress*/
static void * JNICALL bda_c2j_proxy_GetDirectBufferAddress(JNIEnv * env, jobject p1)
{
  /* local variables */
  void * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetDirectBufferAddress++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetDirectBufferAddress++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDirectBufferAddress")
    && bda_check_no_exeception(s, "GetDirectBufferAddress")
    && bda_check_no_critical(s, "GetDirectBufferAddress")
    && bda_check_non_null(s, p1,  1, "GetDirectBufferAddress")
    && bda_check_dref(s, p1, 1, "GetDirectBufferAddress")
    && bda_check_subclass_jobject_jclass(s, p1, bda_clazz_nio_buffer, 1, "GetDirectBufferAddress")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDirectBufferAddress;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetDirectBufferAddress", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "GetDirectBufferAddress" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetDirectBufferAddress(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetDirectBufferAddress", s->name)) {
    printf("<= %-50s %p\n", "GetDirectBufferAddress", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetDirectBufferCapacity*/
static jlong JNICALL bda_c2j_proxy_GetDirectBufferCapacity(JNIEnv * env, jobject p1)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetDirectBufferCapacity++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetDirectBufferCapacity++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDirectBufferCapacity")
    && bda_check_no_exeception(s, "GetDirectBufferCapacity")
    && bda_check_no_critical(s, "GetDirectBufferCapacity")
    && bda_check_non_null(s, p1,  1, "GetDirectBufferCapacity")
    && bda_check_dref(s, p1, 1, "GetDirectBufferCapacity")
    && bda_check_subclass_jobject_jclass(s, p1, bda_clazz_nio_buffer, 1, "GetDirectBufferCapacity")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDirectBufferCapacity;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetDirectBufferCapacity", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "GetDirectBufferCapacity" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetDirectBufferCapacity(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetDirectBufferCapacity", s->name)) {
    printf("<= %-50s %lld\n", "GetDirectBufferCapacity", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetObjectRefType*/
static jobjectRefType JNICALL bda_c2j_proxy_GetObjectRefType(JNIEnv * env, jobject p1)
{
  /* local variables */
  jobjectRefType result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;

  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);

  /* Update call counts. */
  bda_c2j_count.GetObjectRefType++;
  if (s != NULL) {
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetObjectRefType++;}
  }

  /* Check the JNI Function call. */
  if (bda_options.jnicheck && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetObjectRefType")
    && bda_check_no_exeception(s, "GetObjectRefType")
    && bda_check_no_critical(s, "GetObjectRefType")
    && bda_check_non_null(s, p1,  1, "GetObjectRefType")
    && bda_check_dref(s, p1, 1, "GetObjectRefType")
    ;
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetObjectRefType;
#endif
    c2j.env = s->env;
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Trace Prologue. */
  if (bda_options.mname[0] && bda_trace_match("GetObjectRefType", s->name)) {
    printf("=> %-50s %p(JNIEnv *) %p(jobject)\n", "GetObjectRefType" , env, p1);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetObjectRefType(env, p1);
  L_RETURN:

  /* Trace Epilogue. */
  if (bda_options.mname[0] && bda_trace_match("GetObjectRefType", s->name)) {
    printf("<= %-50s %d\n", "GetObjectRefType", result);
  }

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
  }

  /* Check the JNI function return. */
  if ((s != NULL) && bda_options.jnicheck && (s->mode != JVM)) {
  }

  return result;
}

void bda_c2j_proxy_install(jvmtiEnv *jvmti)
{
  jvmtiError err;
  err = (*jvmti)->GetJNIFunctionTable(jvmti, &proxy_jni_funcs);
  assert(err == JVMTI_ERROR_NONE);
  proxy_jni_funcs->GetVersion = bda_c2j_proxy_GetVersion;
  proxy_jni_funcs->DefineClass = bda_c2j_proxy_DefineClass;
  proxy_jni_funcs->FindClass = bda_c2j_proxy_FindClass;
  proxy_jni_funcs->FromReflectedMethod = bda_c2j_proxy_FromReflectedMethod;
  proxy_jni_funcs->FromReflectedField = bda_c2j_proxy_FromReflectedField;
  proxy_jni_funcs->ToReflectedMethod = bda_c2j_proxy_ToReflectedMethod;
  proxy_jni_funcs->GetSuperclass = bda_c2j_proxy_GetSuperclass;
  proxy_jni_funcs->IsAssignableFrom = bda_c2j_proxy_IsAssignableFrom;
  proxy_jni_funcs->ToReflectedField = bda_c2j_proxy_ToReflectedField;
  proxy_jni_funcs->Throw = bda_c2j_proxy_Throw;
  proxy_jni_funcs->ThrowNew = bda_c2j_proxy_ThrowNew;
  proxy_jni_funcs->ExceptionOccurred = bda_c2j_proxy_ExceptionOccurred;
  proxy_jni_funcs->ExceptionDescribe = bda_c2j_proxy_ExceptionDescribe;
  proxy_jni_funcs->ExceptionClear = bda_c2j_proxy_ExceptionClear;
  proxy_jni_funcs->FatalError = bda_c2j_proxy_FatalError;
  proxy_jni_funcs->PushLocalFrame = bda_c2j_proxy_PushLocalFrame;
  proxy_jni_funcs->PopLocalFrame = bda_c2j_proxy_PopLocalFrame;
  proxy_jni_funcs->NewGlobalRef = bda_c2j_proxy_NewGlobalRef;
  proxy_jni_funcs->DeleteGlobalRef = bda_c2j_proxy_DeleteGlobalRef;
  proxy_jni_funcs->DeleteLocalRef = bda_c2j_proxy_DeleteLocalRef;
  proxy_jni_funcs->IsSameObject = bda_c2j_proxy_IsSameObject;
  proxy_jni_funcs->NewLocalRef = bda_c2j_proxy_NewLocalRef;
  proxy_jni_funcs->EnsureLocalCapacity = bda_c2j_proxy_EnsureLocalCapacity;
  proxy_jni_funcs->AllocObject = bda_c2j_proxy_AllocObject;
  proxy_jni_funcs->NewObject = bda_c2j_proxy_NewObject;
  proxy_jni_funcs->NewObjectV = bda_c2j_proxy_NewObjectV;
  proxy_jni_funcs->NewObjectA = bda_c2j_proxy_NewObjectA;
  proxy_jni_funcs->GetObjectClass = bda_c2j_proxy_GetObjectClass;
  proxy_jni_funcs->IsInstanceOf = bda_c2j_proxy_IsInstanceOf;
  proxy_jni_funcs->GetMethodID = bda_c2j_proxy_GetMethodID;
  proxy_jni_funcs->CallObjectMethod = bda_c2j_proxy_CallObjectMethod;
  proxy_jni_funcs->CallObjectMethodV = bda_c2j_proxy_CallObjectMethodV;
  proxy_jni_funcs->CallObjectMethodA = bda_c2j_proxy_CallObjectMethodA;
  proxy_jni_funcs->CallBooleanMethod = bda_c2j_proxy_CallBooleanMethod;
  proxy_jni_funcs->CallBooleanMethodV = bda_c2j_proxy_CallBooleanMethodV;
  proxy_jni_funcs->CallBooleanMethodA = bda_c2j_proxy_CallBooleanMethodA;
  proxy_jni_funcs->CallByteMethod = bda_c2j_proxy_CallByteMethod;
  proxy_jni_funcs->CallByteMethodV = bda_c2j_proxy_CallByteMethodV;
  proxy_jni_funcs->CallByteMethodA = bda_c2j_proxy_CallByteMethodA;
  proxy_jni_funcs->CallCharMethod = bda_c2j_proxy_CallCharMethod;
  proxy_jni_funcs->CallCharMethodV = bda_c2j_proxy_CallCharMethodV;
  proxy_jni_funcs->CallCharMethodA = bda_c2j_proxy_CallCharMethodA;
  proxy_jni_funcs->CallShortMethod = bda_c2j_proxy_CallShortMethod;
  proxy_jni_funcs->CallShortMethodV = bda_c2j_proxy_CallShortMethodV;
  proxy_jni_funcs->CallShortMethodA = bda_c2j_proxy_CallShortMethodA;
  proxy_jni_funcs->CallIntMethod = bda_c2j_proxy_CallIntMethod;
  proxy_jni_funcs->CallIntMethodV = bda_c2j_proxy_CallIntMethodV;
  proxy_jni_funcs->CallIntMethodA = bda_c2j_proxy_CallIntMethodA;
  proxy_jni_funcs->CallLongMethod = bda_c2j_proxy_CallLongMethod;
  proxy_jni_funcs->CallLongMethodV = bda_c2j_proxy_CallLongMethodV;
  proxy_jni_funcs->CallLongMethodA = bda_c2j_proxy_CallLongMethodA;
  proxy_jni_funcs->CallFloatMethod = bda_c2j_proxy_CallFloatMethod;
  proxy_jni_funcs->CallFloatMethodV = bda_c2j_proxy_CallFloatMethodV;
  proxy_jni_funcs->CallFloatMethodA = bda_c2j_proxy_CallFloatMethodA;
  proxy_jni_funcs->CallDoubleMethod = bda_c2j_proxy_CallDoubleMethod;
  proxy_jni_funcs->CallDoubleMethodV = bda_c2j_proxy_CallDoubleMethodV;
  proxy_jni_funcs->CallDoubleMethodA = bda_c2j_proxy_CallDoubleMethodA;
  proxy_jni_funcs->CallVoidMethod = bda_c2j_proxy_CallVoidMethod;
  proxy_jni_funcs->CallVoidMethodV = bda_c2j_proxy_CallVoidMethodV;
  proxy_jni_funcs->CallVoidMethodA = bda_c2j_proxy_CallVoidMethodA;
  proxy_jni_funcs->CallNonvirtualObjectMethod = bda_c2j_proxy_CallNonvirtualObjectMethod;
  proxy_jni_funcs->CallNonvirtualObjectMethodV = bda_c2j_proxy_CallNonvirtualObjectMethodV;
  proxy_jni_funcs->CallNonvirtualObjectMethodA = bda_c2j_proxy_CallNonvirtualObjectMethodA;
  proxy_jni_funcs->CallNonvirtualBooleanMethod = bda_c2j_proxy_CallNonvirtualBooleanMethod;
  proxy_jni_funcs->CallNonvirtualBooleanMethodV = bda_c2j_proxy_CallNonvirtualBooleanMethodV;
  proxy_jni_funcs->CallNonvirtualBooleanMethodA = bda_c2j_proxy_CallNonvirtualBooleanMethodA;
  proxy_jni_funcs->CallNonvirtualByteMethod = bda_c2j_proxy_CallNonvirtualByteMethod;
  proxy_jni_funcs->CallNonvirtualByteMethodV = bda_c2j_proxy_CallNonvirtualByteMethodV;
  proxy_jni_funcs->CallNonvirtualByteMethodA = bda_c2j_proxy_CallNonvirtualByteMethodA;
  proxy_jni_funcs->CallNonvirtualCharMethod = bda_c2j_proxy_CallNonvirtualCharMethod;
  proxy_jni_funcs->CallNonvirtualCharMethodV = bda_c2j_proxy_CallNonvirtualCharMethodV;
  proxy_jni_funcs->CallNonvirtualCharMethodA = bda_c2j_proxy_CallNonvirtualCharMethodA;
  proxy_jni_funcs->CallNonvirtualShortMethod = bda_c2j_proxy_CallNonvirtualShortMethod;
  proxy_jni_funcs->CallNonvirtualShortMethodV = bda_c2j_proxy_CallNonvirtualShortMethodV;
  proxy_jni_funcs->CallNonvirtualShortMethodA = bda_c2j_proxy_CallNonvirtualShortMethodA;
  proxy_jni_funcs->CallNonvirtualIntMethod = bda_c2j_proxy_CallNonvirtualIntMethod;
  proxy_jni_funcs->CallNonvirtualIntMethodV = bda_c2j_proxy_CallNonvirtualIntMethodV;
  proxy_jni_funcs->CallNonvirtualIntMethodA = bda_c2j_proxy_CallNonvirtualIntMethodA;
  proxy_jni_funcs->CallNonvirtualLongMethod = bda_c2j_proxy_CallNonvirtualLongMethod;
  proxy_jni_funcs->CallNonvirtualLongMethodV = bda_c2j_proxy_CallNonvirtualLongMethodV;
  proxy_jni_funcs->CallNonvirtualLongMethodA = bda_c2j_proxy_CallNonvirtualLongMethodA;
  proxy_jni_funcs->CallNonvirtualFloatMethod = bda_c2j_proxy_CallNonvirtualFloatMethod;
  proxy_jni_funcs->CallNonvirtualFloatMethodV = bda_c2j_proxy_CallNonvirtualFloatMethodV;
  proxy_jni_funcs->CallNonvirtualFloatMethodA = bda_c2j_proxy_CallNonvirtualFloatMethodA;
  proxy_jni_funcs->CallNonvirtualDoubleMethod = bda_c2j_proxy_CallNonvirtualDoubleMethod;
  proxy_jni_funcs->CallNonvirtualDoubleMethodV = bda_c2j_proxy_CallNonvirtualDoubleMethodV;
  proxy_jni_funcs->CallNonvirtualDoubleMethodA = bda_c2j_proxy_CallNonvirtualDoubleMethodA;
  proxy_jni_funcs->CallNonvirtualVoidMethod = bda_c2j_proxy_CallNonvirtualVoidMethod;
  proxy_jni_funcs->CallNonvirtualVoidMethodV = bda_c2j_proxy_CallNonvirtualVoidMethodV;
  proxy_jni_funcs->CallNonvirtualVoidMethodA = bda_c2j_proxy_CallNonvirtualVoidMethodA;
  proxy_jni_funcs->GetFieldID = bda_c2j_proxy_GetFieldID;
  proxy_jni_funcs->GetObjectField = bda_c2j_proxy_GetObjectField;
  proxy_jni_funcs->GetBooleanField = bda_c2j_proxy_GetBooleanField;
  proxy_jni_funcs->GetByteField = bda_c2j_proxy_GetByteField;
  proxy_jni_funcs->GetCharField = bda_c2j_proxy_GetCharField;
  proxy_jni_funcs->GetShortField = bda_c2j_proxy_GetShortField;
  proxy_jni_funcs->GetIntField = bda_c2j_proxy_GetIntField;
  proxy_jni_funcs->GetLongField = bda_c2j_proxy_GetLongField;
  proxy_jni_funcs->GetFloatField = bda_c2j_proxy_GetFloatField;
  proxy_jni_funcs->GetDoubleField = bda_c2j_proxy_GetDoubleField;
  proxy_jni_funcs->SetObjectField = bda_c2j_proxy_SetObjectField;
  proxy_jni_funcs->SetBooleanField = bda_c2j_proxy_SetBooleanField;
  proxy_jni_funcs->SetByteField = bda_c2j_proxy_SetByteField;
  proxy_jni_funcs->SetCharField = bda_c2j_proxy_SetCharField;
  proxy_jni_funcs->SetShortField = bda_c2j_proxy_SetShortField;
  proxy_jni_funcs->SetIntField = bda_c2j_proxy_SetIntField;
  proxy_jni_funcs->SetLongField = bda_c2j_proxy_SetLongField;
  proxy_jni_funcs->SetFloatField = bda_c2j_proxy_SetFloatField;
  proxy_jni_funcs->SetDoubleField = bda_c2j_proxy_SetDoubleField;
  proxy_jni_funcs->GetStaticMethodID = bda_c2j_proxy_GetStaticMethodID;
  proxy_jni_funcs->CallStaticObjectMethod = bda_c2j_proxy_CallStaticObjectMethod;
  proxy_jni_funcs->CallStaticObjectMethodV = bda_c2j_proxy_CallStaticObjectMethodV;
  proxy_jni_funcs->CallStaticObjectMethodA = bda_c2j_proxy_CallStaticObjectMethodA;
  proxy_jni_funcs->CallStaticBooleanMethod = bda_c2j_proxy_CallStaticBooleanMethod;
  proxy_jni_funcs->CallStaticBooleanMethodV = bda_c2j_proxy_CallStaticBooleanMethodV;
  proxy_jni_funcs->CallStaticBooleanMethodA = bda_c2j_proxy_CallStaticBooleanMethodA;
  proxy_jni_funcs->CallStaticByteMethod = bda_c2j_proxy_CallStaticByteMethod;
  proxy_jni_funcs->CallStaticByteMethodV = bda_c2j_proxy_CallStaticByteMethodV;
  proxy_jni_funcs->CallStaticByteMethodA = bda_c2j_proxy_CallStaticByteMethodA;
  proxy_jni_funcs->CallStaticCharMethod = bda_c2j_proxy_CallStaticCharMethod;
  proxy_jni_funcs->CallStaticCharMethodV = bda_c2j_proxy_CallStaticCharMethodV;
  proxy_jni_funcs->CallStaticCharMethodA = bda_c2j_proxy_CallStaticCharMethodA;
  proxy_jni_funcs->CallStaticShortMethod = bda_c2j_proxy_CallStaticShortMethod;
  proxy_jni_funcs->CallStaticShortMethodV = bda_c2j_proxy_CallStaticShortMethodV;
  proxy_jni_funcs->CallStaticShortMethodA = bda_c2j_proxy_CallStaticShortMethodA;
  proxy_jni_funcs->CallStaticIntMethod = bda_c2j_proxy_CallStaticIntMethod;
  proxy_jni_funcs->CallStaticIntMethodV = bda_c2j_proxy_CallStaticIntMethodV;
  proxy_jni_funcs->CallStaticIntMethodA = bda_c2j_proxy_CallStaticIntMethodA;
  proxy_jni_funcs->CallStaticLongMethod = bda_c2j_proxy_CallStaticLongMethod;
  proxy_jni_funcs->CallStaticLongMethodV = bda_c2j_proxy_CallStaticLongMethodV;
  proxy_jni_funcs->CallStaticLongMethodA = bda_c2j_proxy_CallStaticLongMethodA;
  proxy_jni_funcs->CallStaticFloatMethod = bda_c2j_proxy_CallStaticFloatMethod;
  proxy_jni_funcs->CallStaticFloatMethodV = bda_c2j_proxy_CallStaticFloatMethodV;
  proxy_jni_funcs->CallStaticFloatMethodA = bda_c2j_proxy_CallStaticFloatMethodA;
  proxy_jni_funcs->CallStaticDoubleMethod = bda_c2j_proxy_CallStaticDoubleMethod;
  proxy_jni_funcs->CallStaticDoubleMethodV = bda_c2j_proxy_CallStaticDoubleMethodV;
  proxy_jni_funcs->CallStaticDoubleMethodA = bda_c2j_proxy_CallStaticDoubleMethodA;
  proxy_jni_funcs->CallStaticVoidMethod = bda_c2j_proxy_CallStaticVoidMethod;
  proxy_jni_funcs->CallStaticVoidMethodV = bda_c2j_proxy_CallStaticVoidMethodV;
  proxy_jni_funcs->CallStaticVoidMethodA = bda_c2j_proxy_CallStaticVoidMethodA;
  proxy_jni_funcs->GetStaticFieldID = bda_c2j_proxy_GetStaticFieldID;
  proxy_jni_funcs->GetStaticObjectField = bda_c2j_proxy_GetStaticObjectField;
  proxy_jni_funcs->GetStaticBooleanField = bda_c2j_proxy_GetStaticBooleanField;
  proxy_jni_funcs->GetStaticByteField = bda_c2j_proxy_GetStaticByteField;
  proxy_jni_funcs->GetStaticCharField = bda_c2j_proxy_GetStaticCharField;
  proxy_jni_funcs->GetStaticShortField = bda_c2j_proxy_GetStaticShortField;
  proxy_jni_funcs->GetStaticIntField = bda_c2j_proxy_GetStaticIntField;
  proxy_jni_funcs->GetStaticLongField = bda_c2j_proxy_GetStaticLongField;
  proxy_jni_funcs->GetStaticFloatField = bda_c2j_proxy_GetStaticFloatField;
  proxy_jni_funcs->GetStaticDoubleField = bda_c2j_proxy_GetStaticDoubleField;
  proxy_jni_funcs->SetStaticObjectField = bda_c2j_proxy_SetStaticObjectField;
  proxy_jni_funcs->SetStaticBooleanField = bda_c2j_proxy_SetStaticBooleanField;
  proxy_jni_funcs->SetStaticByteField = bda_c2j_proxy_SetStaticByteField;
  proxy_jni_funcs->SetStaticCharField = bda_c2j_proxy_SetStaticCharField;
  proxy_jni_funcs->SetStaticShortField = bda_c2j_proxy_SetStaticShortField;
  proxy_jni_funcs->SetStaticIntField = bda_c2j_proxy_SetStaticIntField;
  proxy_jni_funcs->SetStaticLongField = bda_c2j_proxy_SetStaticLongField;
  proxy_jni_funcs->SetStaticFloatField = bda_c2j_proxy_SetStaticFloatField;
  proxy_jni_funcs->SetStaticDoubleField = bda_c2j_proxy_SetStaticDoubleField;
  proxy_jni_funcs->NewString = bda_c2j_proxy_NewString;
  proxy_jni_funcs->GetStringLength = bda_c2j_proxy_GetStringLength;
  proxy_jni_funcs->GetStringChars = bda_c2j_proxy_GetStringChars;
  proxy_jni_funcs->ReleaseStringChars = bda_c2j_proxy_ReleaseStringChars;
  proxy_jni_funcs->NewStringUTF = bda_c2j_proxy_NewStringUTF;
  proxy_jni_funcs->GetStringUTFLength = bda_c2j_proxy_GetStringUTFLength;
  proxy_jni_funcs->GetStringUTFChars = bda_c2j_proxy_GetStringUTFChars;
  proxy_jni_funcs->ReleaseStringUTFChars = bda_c2j_proxy_ReleaseStringUTFChars;
  proxy_jni_funcs->GetArrayLength = bda_c2j_proxy_GetArrayLength;
  proxy_jni_funcs->NewObjectArray = bda_c2j_proxy_NewObjectArray;
  proxy_jni_funcs->GetObjectArrayElement = bda_c2j_proxy_GetObjectArrayElement;
  proxy_jni_funcs->SetObjectArrayElement = bda_c2j_proxy_SetObjectArrayElement;
  proxy_jni_funcs->NewBooleanArray = bda_c2j_proxy_NewBooleanArray;
  proxy_jni_funcs->NewByteArray = bda_c2j_proxy_NewByteArray;
  proxy_jni_funcs->NewCharArray = bda_c2j_proxy_NewCharArray;
  proxy_jni_funcs->NewShortArray = bda_c2j_proxy_NewShortArray;
  proxy_jni_funcs->NewIntArray = bda_c2j_proxy_NewIntArray;
  proxy_jni_funcs->NewLongArray = bda_c2j_proxy_NewLongArray;
  proxy_jni_funcs->NewFloatArray = bda_c2j_proxy_NewFloatArray;
  proxy_jni_funcs->NewDoubleArray = bda_c2j_proxy_NewDoubleArray;
  proxy_jni_funcs->GetBooleanArrayElements = bda_c2j_proxy_GetBooleanArrayElements;
  proxy_jni_funcs->GetByteArrayElements = bda_c2j_proxy_GetByteArrayElements;
  proxy_jni_funcs->GetCharArrayElements = bda_c2j_proxy_GetCharArrayElements;
  proxy_jni_funcs->GetShortArrayElements = bda_c2j_proxy_GetShortArrayElements;
  proxy_jni_funcs->GetIntArrayElements = bda_c2j_proxy_GetIntArrayElements;
  proxy_jni_funcs->GetLongArrayElements = bda_c2j_proxy_GetLongArrayElements;
  proxy_jni_funcs->GetFloatArrayElements = bda_c2j_proxy_GetFloatArrayElements;
  proxy_jni_funcs->GetDoubleArrayElements = bda_c2j_proxy_GetDoubleArrayElements;
  proxy_jni_funcs->ReleaseBooleanArrayElements = bda_c2j_proxy_ReleaseBooleanArrayElements;
  proxy_jni_funcs->ReleaseByteArrayElements = bda_c2j_proxy_ReleaseByteArrayElements;
  proxy_jni_funcs->ReleaseCharArrayElements = bda_c2j_proxy_ReleaseCharArrayElements;
  proxy_jni_funcs->ReleaseShortArrayElements = bda_c2j_proxy_ReleaseShortArrayElements;
  proxy_jni_funcs->ReleaseIntArrayElements = bda_c2j_proxy_ReleaseIntArrayElements;
  proxy_jni_funcs->ReleaseLongArrayElements = bda_c2j_proxy_ReleaseLongArrayElements;
  proxy_jni_funcs->ReleaseFloatArrayElements = bda_c2j_proxy_ReleaseFloatArrayElements;
  proxy_jni_funcs->ReleaseDoubleArrayElements = bda_c2j_proxy_ReleaseDoubleArrayElements;
  proxy_jni_funcs->GetBooleanArrayRegion = bda_c2j_proxy_GetBooleanArrayRegion;
  proxy_jni_funcs->GetByteArrayRegion = bda_c2j_proxy_GetByteArrayRegion;
  proxy_jni_funcs->GetCharArrayRegion = bda_c2j_proxy_GetCharArrayRegion;
  proxy_jni_funcs->GetShortArrayRegion = bda_c2j_proxy_GetShortArrayRegion;
  proxy_jni_funcs->GetIntArrayRegion = bda_c2j_proxy_GetIntArrayRegion;
  proxy_jni_funcs->GetLongArrayRegion = bda_c2j_proxy_GetLongArrayRegion;
  proxy_jni_funcs->GetFloatArrayRegion = bda_c2j_proxy_GetFloatArrayRegion;
  proxy_jni_funcs->GetDoubleArrayRegion = bda_c2j_proxy_GetDoubleArrayRegion;
  proxy_jni_funcs->SetBooleanArrayRegion = bda_c2j_proxy_SetBooleanArrayRegion;
  proxy_jni_funcs->SetByteArrayRegion = bda_c2j_proxy_SetByteArrayRegion;
  proxy_jni_funcs->SetCharArrayRegion = bda_c2j_proxy_SetCharArrayRegion;
  proxy_jni_funcs->SetShortArrayRegion = bda_c2j_proxy_SetShortArrayRegion;
  proxy_jni_funcs->SetIntArrayRegion = bda_c2j_proxy_SetIntArrayRegion;
  proxy_jni_funcs->SetLongArrayRegion = bda_c2j_proxy_SetLongArrayRegion;
  proxy_jni_funcs->SetFloatArrayRegion = bda_c2j_proxy_SetFloatArrayRegion;
  proxy_jni_funcs->SetDoubleArrayRegion = bda_c2j_proxy_SetDoubleArrayRegion;
  proxy_jni_funcs->RegisterNatives = bda_c2j_proxy_RegisterNatives;
  proxy_jni_funcs->UnregisterNatives = bda_c2j_proxy_UnregisterNatives;
  proxy_jni_funcs->MonitorEnter = bda_c2j_proxy_MonitorEnter;
  proxy_jni_funcs->MonitorExit = bda_c2j_proxy_MonitorExit;
  proxy_jni_funcs->GetJavaVM = bda_c2j_proxy_GetJavaVM;
  proxy_jni_funcs->GetStringRegion = bda_c2j_proxy_GetStringRegion;
  proxy_jni_funcs->GetStringUTFRegion = bda_c2j_proxy_GetStringUTFRegion;
  proxy_jni_funcs->GetPrimitiveArrayCritical = bda_c2j_proxy_GetPrimitiveArrayCritical;
  proxy_jni_funcs->ReleasePrimitiveArrayCritical = bda_c2j_proxy_ReleasePrimitiveArrayCritical;
  proxy_jni_funcs->GetStringCritical = bda_c2j_proxy_GetStringCritical;
  proxy_jni_funcs->ReleaseStringCritical = bda_c2j_proxy_ReleaseStringCritical;
  proxy_jni_funcs->NewWeakGlobalRef = bda_c2j_proxy_NewWeakGlobalRef;
  proxy_jni_funcs->DeleteWeakGlobalRef = bda_c2j_proxy_DeleteWeakGlobalRef;
  proxy_jni_funcs->ExceptionCheck = bda_c2j_proxy_ExceptionCheck;
  proxy_jni_funcs->NewDirectByteBuffer = bda_c2j_proxy_NewDirectByteBuffer;
  proxy_jni_funcs->GetDirectBufferAddress = bda_c2j_proxy_GetDirectBufferAddress;
  proxy_jni_funcs->GetDirectBufferCapacity = bda_c2j_proxy_GetDirectBufferCapacity;
  proxy_jni_funcs->GetObjectRefType = bda_c2j_proxy_GetObjectRefType;
  err = (*jvmti)->SetJNIFunctionTable(jvmti, proxy_jni_funcs);
}
void bda_c2j_proxy_dump_stat()
{
  int sum = 0;
  int sum_user = 0;
  printf("JNI function call statistics\n");
  printf("%7d %7d %s\n", bda_c2j_count.GetVersion, bda_c2j_count_user.GetVersion, "GetVersion");  sum += bda_c2j_count.GetVersion;
  sum_user += bda_c2j_count_user.GetVersion;
  printf("%7d %7d %s\n", bda_c2j_count.DefineClass, bda_c2j_count_user.DefineClass, "DefineClass");  sum += bda_c2j_count.DefineClass;
  sum_user += bda_c2j_count_user.DefineClass;
  printf("%7d %7d %s\n", bda_c2j_count.FindClass, bda_c2j_count_user.FindClass, "FindClass");  sum += bda_c2j_count.FindClass;
  sum_user += bda_c2j_count_user.FindClass;
  printf("%7d %7d %s\n", bda_c2j_count.FromReflectedMethod, bda_c2j_count_user.FromReflectedMethod, "FromReflectedMethod");  sum += bda_c2j_count.FromReflectedMethod;
  sum_user += bda_c2j_count_user.FromReflectedMethod;
  printf("%7d %7d %s\n", bda_c2j_count.FromReflectedField, bda_c2j_count_user.FromReflectedField, "FromReflectedField");  sum += bda_c2j_count.FromReflectedField;
  sum_user += bda_c2j_count_user.FromReflectedField;
  printf("%7d %7d %s\n", bda_c2j_count.ToReflectedMethod, bda_c2j_count_user.ToReflectedMethod, "ToReflectedMethod");  sum += bda_c2j_count.ToReflectedMethod;
  sum_user += bda_c2j_count_user.ToReflectedMethod;
  printf("%7d %7d %s\n", bda_c2j_count.GetSuperclass, bda_c2j_count_user.GetSuperclass, "GetSuperclass");  sum += bda_c2j_count.GetSuperclass;
  sum_user += bda_c2j_count_user.GetSuperclass;
  printf("%7d %7d %s\n", bda_c2j_count.IsAssignableFrom, bda_c2j_count_user.IsAssignableFrom, "IsAssignableFrom");  sum += bda_c2j_count.IsAssignableFrom;
  sum_user += bda_c2j_count_user.IsAssignableFrom;
  printf("%7d %7d %s\n", bda_c2j_count.ToReflectedField, bda_c2j_count_user.ToReflectedField, "ToReflectedField");  sum += bda_c2j_count.ToReflectedField;
  sum_user += bda_c2j_count_user.ToReflectedField;
  printf("%7d %7d %s\n", bda_c2j_count.Throw, bda_c2j_count_user.Throw, "Throw");  sum += bda_c2j_count.Throw;
  sum_user += bda_c2j_count_user.Throw;
  printf("%7d %7d %s\n", bda_c2j_count.ThrowNew, bda_c2j_count_user.ThrowNew, "ThrowNew");  sum += bda_c2j_count.ThrowNew;
  sum_user += bda_c2j_count_user.ThrowNew;
  printf("%7d %7d %s\n", bda_c2j_count.ExceptionOccurred, bda_c2j_count_user.ExceptionOccurred, "ExceptionOccurred");  sum += bda_c2j_count.ExceptionOccurred;
  sum_user += bda_c2j_count_user.ExceptionOccurred;
  printf("%7d %7d %s\n", bda_c2j_count.ExceptionDescribe, bda_c2j_count_user.ExceptionDescribe, "ExceptionDescribe");  sum += bda_c2j_count.ExceptionDescribe;
  sum_user += bda_c2j_count_user.ExceptionDescribe;
  printf("%7d %7d %s\n", bda_c2j_count.ExceptionClear, bda_c2j_count_user.ExceptionClear, "ExceptionClear");  sum += bda_c2j_count.ExceptionClear;
  sum_user += bda_c2j_count_user.ExceptionClear;
  printf("%7d %7d %s\n", bda_c2j_count.FatalError, bda_c2j_count_user.FatalError, "FatalError");  sum += bda_c2j_count.FatalError;
  sum_user += bda_c2j_count_user.FatalError;
  printf("%7d %7d %s\n", bda_c2j_count.PushLocalFrame, bda_c2j_count_user.PushLocalFrame, "PushLocalFrame");  sum += bda_c2j_count.PushLocalFrame;
  sum_user += bda_c2j_count_user.PushLocalFrame;
  printf("%7d %7d %s\n", bda_c2j_count.PopLocalFrame, bda_c2j_count_user.PopLocalFrame, "PopLocalFrame");  sum += bda_c2j_count.PopLocalFrame;
  sum_user += bda_c2j_count_user.PopLocalFrame;
  printf("%7d %7d %s\n", bda_c2j_count.NewGlobalRef, bda_c2j_count_user.NewGlobalRef, "NewGlobalRef");  sum += bda_c2j_count.NewGlobalRef;
  sum_user += bda_c2j_count_user.NewGlobalRef;
  printf("%7d %7d %s\n", bda_c2j_count.DeleteGlobalRef, bda_c2j_count_user.DeleteGlobalRef, "DeleteGlobalRef");  sum += bda_c2j_count.DeleteGlobalRef;
  sum_user += bda_c2j_count_user.DeleteGlobalRef;
  printf("%7d %7d %s\n", bda_c2j_count.DeleteLocalRef, bda_c2j_count_user.DeleteLocalRef, "DeleteLocalRef");  sum += bda_c2j_count.DeleteLocalRef;
  sum_user += bda_c2j_count_user.DeleteLocalRef;
  printf("%7d %7d %s\n", bda_c2j_count.IsSameObject, bda_c2j_count_user.IsSameObject, "IsSameObject");  sum += bda_c2j_count.IsSameObject;
  sum_user += bda_c2j_count_user.IsSameObject;
  printf("%7d %7d %s\n", bda_c2j_count.NewLocalRef, bda_c2j_count_user.NewLocalRef, "NewLocalRef");  sum += bda_c2j_count.NewLocalRef;
  sum_user += bda_c2j_count_user.NewLocalRef;
  printf("%7d %7d %s\n", bda_c2j_count.EnsureLocalCapacity, bda_c2j_count_user.EnsureLocalCapacity, "EnsureLocalCapacity");  sum += bda_c2j_count.EnsureLocalCapacity;
  sum_user += bda_c2j_count_user.EnsureLocalCapacity;
  printf("%7d %7d %s\n", bda_c2j_count.AllocObject, bda_c2j_count_user.AllocObject, "AllocObject");  sum += bda_c2j_count.AllocObject;
  sum_user += bda_c2j_count_user.AllocObject;
  printf("%7d %7d %s\n", bda_c2j_count.NewObject, bda_c2j_count_user.NewObject, "NewObject");  sum += bda_c2j_count.NewObject;
  sum_user += bda_c2j_count_user.NewObject;
  printf("%7d %7d %s\n", bda_c2j_count.NewObjectV, bda_c2j_count_user.NewObjectV, "NewObjectV");  sum += bda_c2j_count.NewObjectV;
  sum_user += bda_c2j_count_user.NewObjectV;
  printf("%7d %7d %s\n", bda_c2j_count.NewObjectA, bda_c2j_count_user.NewObjectA, "NewObjectA");  sum += bda_c2j_count.NewObjectA;
  sum_user += bda_c2j_count_user.NewObjectA;
  printf("%7d %7d %s\n", bda_c2j_count.GetObjectClass, bda_c2j_count_user.GetObjectClass, "GetObjectClass");  sum += bda_c2j_count.GetObjectClass;
  sum_user += bda_c2j_count_user.GetObjectClass;
  printf("%7d %7d %s\n", bda_c2j_count.IsInstanceOf, bda_c2j_count_user.IsInstanceOf, "IsInstanceOf");  sum += bda_c2j_count.IsInstanceOf;
  sum_user += bda_c2j_count_user.IsInstanceOf;
  printf("%7d %7d %s\n", bda_c2j_count.GetMethodID, bda_c2j_count_user.GetMethodID, "GetMethodID");  sum += bda_c2j_count.GetMethodID;
  sum_user += bda_c2j_count_user.GetMethodID;
  printf("%7d %7d %s\n", bda_c2j_count.CallObjectMethod, bda_c2j_count_user.CallObjectMethod, "CallObjectMethod");  sum += bda_c2j_count.CallObjectMethod;
  sum_user += bda_c2j_count_user.CallObjectMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallObjectMethodV, bda_c2j_count_user.CallObjectMethodV, "CallObjectMethodV");  sum += bda_c2j_count.CallObjectMethodV;
  sum_user += bda_c2j_count_user.CallObjectMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallObjectMethodA, bda_c2j_count_user.CallObjectMethodA, "CallObjectMethodA");  sum += bda_c2j_count.CallObjectMethodA;
  sum_user += bda_c2j_count_user.CallObjectMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallBooleanMethod, bda_c2j_count_user.CallBooleanMethod, "CallBooleanMethod");  sum += bda_c2j_count.CallBooleanMethod;
  sum_user += bda_c2j_count_user.CallBooleanMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallBooleanMethodV, bda_c2j_count_user.CallBooleanMethodV, "CallBooleanMethodV");  sum += bda_c2j_count.CallBooleanMethodV;
  sum_user += bda_c2j_count_user.CallBooleanMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallBooleanMethodA, bda_c2j_count_user.CallBooleanMethodA, "CallBooleanMethodA");  sum += bda_c2j_count.CallBooleanMethodA;
  sum_user += bda_c2j_count_user.CallBooleanMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallByteMethod, bda_c2j_count_user.CallByteMethod, "CallByteMethod");  sum += bda_c2j_count.CallByteMethod;
  sum_user += bda_c2j_count_user.CallByteMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallByteMethodV, bda_c2j_count_user.CallByteMethodV, "CallByteMethodV");  sum += bda_c2j_count.CallByteMethodV;
  sum_user += bda_c2j_count_user.CallByteMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallByteMethodA, bda_c2j_count_user.CallByteMethodA, "CallByteMethodA");  sum += bda_c2j_count.CallByteMethodA;
  sum_user += bda_c2j_count_user.CallByteMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallCharMethod, bda_c2j_count_user.CallCharMethod, "CallCharMethod");  sum += bda_c2j_count.CallCharMethod;
  sum_user += bda_c2j_count_user.CallCharMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallCharMethodV, bda_c2j_count_user.CallCharMethodV, "CallCharMethodV");  sum += bda_c2j_count.CallCharMethodV;
  sum_user += bda_c2j_count_user.CallCharMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallCharMethodA, bda_c2j_count_user.CallCharMethodA, "CallCharMethodA");  sum += bda_c2j_count.CallCharMethodA;
  sum_user += bda_c2j_count_user.CallCharMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallShortMethod, bda_c2j_count_user.CallShortMethod, "CallShortMethod");  sum += bda_c2j_count.CallShortMethod;
  sum_user += bda_c2j_count_user.CallShortMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallShortMethodV, bda_c2j_count_user.CallShortMethodV, "CallShortMethodV");  sum += bda_c2j_count.CallShortMethodV;
  sum_user += bda_c2j_count_user.CallShortMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallShortMethodA, bda_c2j_count_user.CallShortMethodA, "CallShortMethodA");  sum += bda_c2j_count.CallShortMethodA;
  sum_user += bda_c2j_count_user.CallShortMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallIntMethod, bda_c2j_count_user.CallIntMethod, "CallIntMethod");  sum += bda_c2j_count.CallIntMethod;
  sum_user += bda_c2j_count_user.CallIntMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallIntMethodV, bda_c2j_count_user.CallIntMethodV, "CallIntMethodV");  sum += bda_c2j_count.CallIntMethodV;
  sum_user += bda_c2j_count_user.CallIntMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallIntMethodA, bda_c2j_count_user.CallIntMethodA, "CallIntMethodA");  sum += bda_c2j_count.CallIntMethodA;
  sum_user += bda_c2j_count_user.CallIntMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallLongMethod, bda_c2j_count_user.CallLongMethod, "CallLongMethod");  sum += bda_c2j_count.CallLongMethod;
  sum_user += bda_c2j_count_user.CallLongMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallLongMethodV, bda_c2j_count_user.CallLongMethodV, "CallLongMethodV");  sum += bda_c2j_count.CallLongMethodV;
  sum_user += bda_c2j_count_user.CallLongMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallLongMethodA, bda_c2j_count_user.CallLongMethodA, "CallLongMethodA");  sum += bda_c2j_count.CallLongMethodA;
  sum_user += bda_c2j_count_user.CallLongMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallFloatMethod, bda_c2j_count_user.CallFloatMethod, "CallFloatMethod");  sum += bda_c2j_count.CallFloatMethod;
  sum_user += bda_c2j_count_user.CallFloatMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallFloatMethodV, bda_c2j_count_user.CallFloatMethodV, "CallFloatMethodV");  sum += bda_c2j_count.CallFloatMethodV;
  sum_user += bda_c2j_count_user.CallFloatMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallFloatMethodA, bda_c2j_count_user.CallFloatMethodA, "CallFloatMethodA");  sum += bda_c2j_count.CallFloatMethodA;
  sum_user += bda_c2j_count_user.CallFloatMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallDoubleMethod, bda_c2j_count_user.CallDoubleMethod, "CallDoubleMethod");  sum += bda_c2j_count.CallDoubleMethod;
  sum_user += bda_c2j_count_user.CallDoubleMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallDoubleMethodV, bda_c2j_count_user.CallDoubleMethodV, "CallDoubleMethodV");  sum += bda_c2j_count.CallDoubleMethodV;
  sum_user += bda_c2j_count_user.CallDoubleMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallDoubleMethodA, bda_c2j_count_user.CallDoubleMethodA, "CallDoubleMethodA");  sum += bda_c2j_count.CallDoubleMethodA;
  sum_user += bda_c2j_count_user.CallDoubleMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallVoidMethod, bda_c2j_count_user.CallVoidMethod, "CallVoidMethod");  sum += bda_c2j_count.CallVoidMethod;
  sum_user += bda_c2j_count_user.CallVoidMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallVoidMethodV, bda_c2j_count_user.CallVoidMethodV, "CallVoidMethodV");  sum += bda_c2j_count.CallVoidMethodV;
  sum_user += bda_c2j_count_user.CallVoidMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallVoidMethodA, bda_c2j_count_user.CallVoidMethodA, "CallVoidMethodA");  sum += bda_c2j_count.CallVoidMethodA;
  sum_user += bda_c2j_count_user.CallVoidMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualObjectMethod, bda_c2j_count_user.CallNonvirtualObjectMethod, "CallNonvirtualObjectMethod");  sum += bda_c2j_count.CallNonvirtualObjectMethod;
  sum_user += bda_c2j_count_user.CallNonvirtualObjectMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualObjectMethodV, bda_c2j_count_user.CallNonvirtualObjectMethodV, "CallNonvirtualObjectMethodV");  sum += bda_c2j_count.CallNonvirtualObjectMethodV;
  sum_user += bda_c2j_count_user.CallNonvirtualObjectMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualObjectMethodA, bda_c2j_count_user.CallNonvirtualObjectMethodA, "CallNonvirtualObjectMethodA");  sum += bda_c2j_count.CallNonvirtualObjectMethodA;
  sum_user += bda_c2j_count_user.CallNonvirtualObjectMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualBooleanMethod, bda_c2j_count_user.CallNonvirtualBooleanMethod, "CallNonvirtualBooleanMethod");  sum += bda_c2j_count.CallNonvirtualBooleanMethod;
  sum_user += bda_c2j_count_user.CallNonvirtualBooleanMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualBooleanMethodV, bda_c2j_count_user.CallNonvirtualBooleanMethodV, "CallNonvirtualBooleanMethodV");  sum += bda_c2j_count.CallNonvirtualBooleanMethodV;
  sum_user += bda_c2j_count_user.CallNonvirtualBooleanMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualBooleanMethodA, bda_c2j_count_user.CallNonvirtualBooleanMethodA, "CallNonvirtualBooleanMethodA");  sum += bda_c2j_count.CallNonvirtualBooleanMethodA;
  sum_user += bda_c2j_count_user.CallNonvirtualBooleanMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualByteMethod, bda_c2j_count_user.CallNonvirtualByteMethod, "CallNonvirtualByteMethod");  sum += bda_c2j_count.CallNonvirtualByteMethod;
  sum_user += bda_c2j_count_user.CallNonvirtualByteMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualByteMethodV, bda_c2j_count_user.CallNonvirtualByteMethodV, "CallNonvirtualByteMethodV");  sum += bda_c2j_count.CallNonvirtualByteMethodV;
  sum_user += bda_c2j_count_user.CallNonvirtualByteMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualByteMethodA, bda_c2j_count_user.CallNonvirtualByteMethodA, "CallNonvirtualByteMethodA");  sum += bda_c2j_count.CallNonvirtualByteMethodA;
  sum_user += bda_c2j_count_user.CallNonvirtualByteMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualCharMethod, bda_c2j_count_user.CallNonvirtualCharMethod, "CallNonvirtualCharMethod");  sum += bda_c2j_count.CallNonvirtualCharMethod;
  sum_user += bda_c2j_count_user.CallNonvirtualCharMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualCharMethodV, bda_c2j_count_user.CallNonvirtualCharMethodV, "CallNonvirtualCharMethodV");  sum += bda_c2j_count.CallNonvirtualCharMethodV;
  sum_user += bda_c2j_count_user.CallNonvirtualCharMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualCharMethodA, bda_c2j_count_user.CallNonvirtualCharMethodA, "CallNonvirtualCharMethodA");  sum += bda_c2j_count.CallNonvirtualCharMethodA;
  sum_user += bda_c2j_count_user.CallNonvirtualCharMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualShortMethod, bda_c2j_count_user.CallNonvirtualShortMethod, "CallNonvirtualShortMethod");  sum += bda_c2j_count.CallNonvirtualShortMethod;
  sum_user += bda_c2j_count_user.CallNonvirtualShortMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualShortMethodV, bda_c2j_count_user.CallNonvirtualShortMethodV, "CallNonvirtualShortMethodV");  sum += bda_c2j_count.CallNonvirtualShortMethodV;
  sum_user += bda_c2j_count_user.CallNonvirtualShortMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualShortMethodA, bda_c2j_count_user.CallNonvirtualShortMethodA, "CallNonvirtualShortMethodA");  sum += bda_c2j_count.CallNonvirtualShortMethodA;
  sum_user += bda_c2j_count_user.CallNonvirtualShortMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualIntMethod, bda_c2j_count_user.CallNonvirtualIntMethod, "CallNonvirtualIntMethod");  sum += bda_c2j_count.CallNonvirtualIntMethod;
  sum_user += bda_c2j_count_user.CallNonvirtualIntMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualIntMethodV, bda_c2j_count_user.CallNonvirtualIntMethodV, "CallNonvirtualIntMethodV");  sum += bda_c2j_count.CallNonvirtualIntMethodV;
  sum_user += bda_c2j_count_user.CallNonvirtualIntMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualIntMethodA, bda_c2j_count_user.CallNonvirtualIntMethodA, "CallNonvirtualIntMethodA");  sum += bda_c2j_count.CallNonvirtualIntMethodA;
  sum_user += bda_c2j_count_user.CallNonvirtualIntMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualLongMethod, bda_c2j_count_user.CallNonvirtualLongMethod, "CallNonvirtualLongMethod");  sum += bda_c2j_count.CallNonvirtualLongMethod;
  sum_user += bda_c2j_count_user.CallNonvirtualLongMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualLongMethodV, bda_c2j_count_user.CallNonvirtualLongMethodV, "CallNonvirtualLongMethodV");  sum += bda_c2j_count.CallNonvirtualLongMethodV;
  sum_user += bda_c2j_count_user.CallNonvirtualLongMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualLongMethodA, bda_c2j_count_user.CallNonvirtualLongMethodA, "CallNonvirtualLongMethodA");  sum += bda_c2j_count.CallNonvirtualLongMethodA;
  sum_user += bda_c2j_count_user.CallNonvirtualLongMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualFloatMethod, bda_c2j_count_user.CallNonvirtualFloatMethod, "CallNonvirtualFloatMethod");  sum += bda_c2j_count.CallNonvirtualFloatMethod;
  sum_user += bda_c2j_count_user.CallNonvirtualFloatMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualFloatMethodV, bda_c2j_count_user.CallNonvirtualFloatMethodV, "CallNonvirtualFloatMethodV");  sum += bda_c2j_count.CallNonvirtualFloatMethodV;
  sum_user += bda_c2j_count_user.CallNonvirtualFloatMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualFloatMethodA, bda_c2j_count_user.CallNonvirtualFloatMethodA, "CallNonvirtualFloatMethodA");  sum += bda_c2j_count.CallNonvirtualFloatMethodA;
  sum_user += bda_c2j_count_user.CallNonvirtualFloatMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualDoubleMethod, bda_c2j_count_user.CallNonvirtualDoubleMethod, "CallNonvirtualDoubleMethod");  sum += bda_c2j_count.CallNonvirtualDoubleMethod;
  sum_user += bda_c2j_count_user.CallNonvirtualDoubleMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualDoubleMethodV, bda_c2j_count_user.CallNonvirtualDoubleMethodV, "CallNonvirtualDoubleMethodV");  sum += bda_c2j_count.CallNonvirtualDoubleMethodV;
  sum_user += bda_c2j_count_user.CallNonvirtualDoubleMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualDoubleMethodA, bda_c2j_count_user.CallNonvirtualDoubleMethodA, "CallNonvirtualDoubleMethodA");  sum += bda_c2j_count.CallNonvirtualDoubleMethodA;
  sum_user += bda_c2j_count_user.CallNonvirtualDoubleMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualVoidMethod, bda_c2j_count_user.CallNonvirtualVoidMethod, "CallNonvirtualVoidMethod");  sum += bda_c2j_count.CallNonvirtualVoidMethod;
  sum_user += bda_c2j_count_user.CallNonvirtualVoidMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualVoidMethodV, bda_c2j_count_user.CallNonvirtualVoidMethodV, "CallNonvirtualVoidMethodV");  sum += bda_c2j_count.CallNonvirtualVoidMethodV;
  sum_user += bda_c2j_count_user.CallNonvirtualVoidMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallNonvirtualVoidMethodA, bda_c2j_count_user.CallNonvirtualVoidMethodA, "CallNonvirtualVoidMethodA");  sum += bda_c2j_count.CallNonvirtualVoidMethodA;
  sum_user += bda_c2j_count_user.CallNonvirtualVoidMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.GetFieldID, bda_c2j_count_user.GetFieldID, "GetFieldID");  sum += bda_c2j_count.GetFieldID;
  sum_user += bda_c2j_count_user.GetFieldID;
  printf("%7d %7d %s\n", bda_c2j_count.GetObjectField, bda_c2j_count_user.GetObjectField, "GetObjectField");  sum += bda_c2j_count.GetObjectField;
  sum_user += bda_c2j_count_user.GetObjectField;
  printf("%7d %7d %s\n", bda_c2j_count.GetBooleanField, bda_c2j_count_user.GetBooleanField, "GetBooleanField");  sum += bda_c2j_count.GetBooleanField;
  sum_user += bda_c2j_count_user.GetBooleanField;
  printf("%7d %7d %s\n", bda_c2j_count.GetByteField, bda_c2j_count_user.GetByteField, "GetByteField");  sum += bda_c2j_count.GetByteField;
  sum_user += bda_c2j_count_user.GetByteField;
  printf("%7d %7d %s\n", bda_c2j_count.GetCharField, bda_c2j_count_user.GetCharField, "GetCharField");  sum += bda_c2j_count.GetCharField;
  sum_user += bda_c2j_count_user.GetCharField;
  printf("%7d %7d %s\n", bda_c2j_count.GetShortField, bda_c2j_count_user.GetShortField, "GetShortField");  sum += bda_c2j_count.GetShortField;
  sum_user += bda_c2j_count_user.GetShortField;
  printf("%7d %7d %s\n", bda_c2j_count.GetIntField, bda_c2j_count_user.GetIntField, "GetIntField");  sum += bda_c2j_count.GetIntField;
  sum_user += bda_c2j_count_user.GetIntField;
  printf("%7d %7d %s\n", bda_c2j_count.GetLongField, bda_c2j_count_user.GetLongField, "GetLongField");  sum += bda_c2j_count.GetLongField;
  sum_user += bda_c2j_count_user.GetLongField;
  printf("%7d %7d %s\n", bda_c2j_count.GetFloatField, bda_c2j_count_user.GetFloatField, "GetFloatField");  sum += bda_c2j_count.GetFloatField;
  sum_user += bda_c2j_count_user.GetFloatField;
  printf("%7d %7d %s\n", bda_c2j_count.GetDoubleField, bda_c2j_count_user.GetDoubleField, "GetDoubleField");  sum += bda_c2j_count.GetDoubleField;
  sum_user += bda_c2j_count_user.GetDoubleField;
  printf("%7d %7d %s\n", bda_c2j_count.SetObjectField, bda_c2j_count_user.SetObjectField, "SetObjectField");  sum += bda_c2j_count.SetObjectField;
  sum_user += bda_c2j_count_user.SetObjectField;
  printf("%7d %7d %s\n", bda_c2j_count.SetBooleanField, bda_c2j_count_user.SetBooleanField, "SetBooleanField");  sum += bda_c2j_count.SetBooleanField;
  sum_user += bda_c2j_count_user.SetBooleanField;
  printf("%7d %7d %s\n", bda_c2j_count.SetByteField, bda_c2j_count_user.SetByteField, "SetByteField");  sum += bda_c2j_count.SetByteField;
  sum_user += bda_c2j_count_user.SetByteField;
  printf("%7d %7d %s\n", bda_c2j_count.SetCharField, bda_c2j_count_user.SetCharField, "SetCharField");  sum += bda_c2j_count.SetCharField;
  sum_user += bda_c2j_count_user.SetCharField;
  printf("%7d %7d %s\n", bda_c2j_count.SetShortField, bda_c2j_count_user.SetShortField, "SetShortField");  sum += bda_c2j_count.SetShortField;
  sum_user += bda_c2j_count_user.SetShortField;
  printf("%7d %7d %s\n", bda_c2j_count.SetIntField, bda_c2j_count_user.SetIntField, "SetIntField");  sum += bda_c2j_count.SetIntField;
  sum_user += bda_c2j_count_user.SetIntField;
  printf("%7d %7d %s\n", bda_c2j_count.SetLongField, bda_c2j_count_user.SetLongField, "SetLongField");  sum += bda_c2j_count.SetLongField;
  sum_user += bda_c2j_count_user.SetLongField;
  printf("%7d %7d %s\n", bda_c2j_count.SetFloatField, bda_c2j_count_user.SetFloatField, "SetFloatField");  sum += bda_c2j_count.SetFloatField;
  sum_user += bda_c2j_count_user.SetFloatField;
  printf("%7d %7d %s\n", bda_c2j_count.SetDoubleField, bda_c2j_count_user.SetDoubleField, "SetDoubleField");  sum += bda_c2j_count.SetDoubleField;
  sum_user += bda_c2j_count_user.SetDoubleField;
  printf("%7d %7d %s\n", bda_c2j_count.GetStaticMethodID, bda_c2j_count_user.GetStaticMethodID, "GetStaticMethodID");  sum += bda_c2j_count.GetStaticMethodID;
  sum_user += bda_c2j_count_user.GetStaticMethodID;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticObjectMethod, bda_c2j_count_user.CallStaticObjectMethod, "CallStaticObjectMethod");  sum += bda_c2j_count.CallStaticObjectMethod;
  sum_user += bda_c2j_count_user.CallStaticObjectMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticObjectMethodV, bda_c2j_count_user.CallStaticObjectMethodV, "CallStaticObjectMethodV");  sum += bda_c2j_count.CallStaticObjectMethodV;
  sum_user += bda_c2j_count_user.CallStaticObjectMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticObjectMethodA, bda_c2j_count_user.CallStaticObjectMethodA, "CallStaticObjectMethodA");  sum += bda_c2j_count.CallStaticObjectMethodA;
  sum_user += bda_c2j_count_user.CallStaticObjectMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticBooleanMethod, bda_c2j_count_user.CallStaticBooleanMethod, "CallStaticBooleanMethod");  sum += bda_c2j_count.CallStaticBooleanMethod;
  sum_user += bda_c2j_count_user.CallStaticBooleanMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticBooleanMethodV, bda_c2j_count_user.CallStaticBooleanMethodV, "CallStaticBooleanMethodV");  sum += bda_c2j_count.CallStaticBooleanMethodV;
  sum_user += bda_c2j_count_user.CallStaticBooleanMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticBooleanMethodA, bda_c2j_count_user.CallStaticBooleanMethodA, "CallStaticBooleanMethodA");  sum += bda_c2j_count.CallStaticBooleanMethodA;
  sum_user += bda_c2j_count_user.CallStaticBooleanMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticByteMethod, bda_c2j_count_user.CallStaticByteMethod, "CallStaticByteMethod");  sum += bda_c2j_count.CallStaticByteMethod;
  sum_user += bda_c2j_count_user.CallStaticByteMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticByteMethodV, bda_c2j_count_user.CallStaticByteMethodV, "CallStaticByteMethodV");  sum += bda_c2j_count.CallStaticByteMethodV;
  sum_user += bda_c2j_count_user.CallStaticByteMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticByteMethodA, bda_c2j_count_user.CallStaticByteMethodA, "CallStaticByteMethodA");  sum += bda_c2j_count.CallStaticByteMethodA;
  sum_user += bda_c2j_count_user.CallStaticByteMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticCharMethod, bda_c2j_count_user.CallStaticCharMethod, "CallStaticCharMethod");  sum += bda_c2j_count.CallStaticCharMethod;
  sum_user += bda_c2j_count_user.CallStaticCharMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticCharMethodV, bda_c2j_count_user.CallStaticCharMethodV, "CallStaticCharMethodV");  sum += bda_c2j_count.CallStaticCharMethodV;
  sum_user += bda_c2j_count_user.CallStaticCharMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticCharMethodA, bda_c2j_count_user.CallStaticCharMethodA, "CallStaticCharMethodA");  sum += bda_c2j_count.CallStaticCharMethodA;
  sum_user += bda_c2j_count_user.CallStaticCharMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticShortMethod, bda_c2j_count_user.CallStaticShortMethod, "CallStaticShortMethod");  sum += bda_c2j_count.CallStaticShortMethod;
  sum_user += bda_c2j_count_user.CallStaticShortMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticShortMethodV, bda_c2j_count_user.CallStaticShortMethodV, "CallStaticShortMethodV");  sum += bda_c2j_count.CallStaticShortMethodV;
  sum_user += bda_c2j_count_user.CallStaticShortMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticShortMethodA, bda_c2j_count_user.CallStaticShortMethodA, "CallStaticShortMethodA");  sum += bda_c2j_count.CallStaticShortMethodA;
  sum_user += bda_c2j_count_user.CallStaticShortMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticIntMethod, bda_c2j_count_user.CallStaticIntMethod, "CallStaticIntMethod");  sum += bda_c2j_count.CallStaticIntMethod;
  sum_user += bda_c2j_count_user.CallStaticIntMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticIntMethodV, bda_c2j_count_user.CallStaticIntMethodV, "CallStaticIntMethodV");  sum += bda_c2j_count.CallStaticIntMethodV;
  sum_user += bda_c2j_count_user.CallStaticIntMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticIntMethodA, bda_c2j_count_user.CallStaticIntMethodA, "CallStaticIntMethodA");  sum += bda_c2j_count.CallStaticIntMethodA;
  sum_user += bda_c2j_count_user.CallStaticIntMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticLongMethod, bda_c2j_count_user.CallStaticLongMethod, "CallStaticLongMethod");  sum += bda_c2j_count.CallStaticLongMethod;
  sum_user += bda_c2j_count_user.CallStaticLongMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticLongMethodV, bda_c2j_count_user.CallStaticLongMethodV, "CallStaticLongMethodV");  sum += bda_c2j_count.CallStaticLongMethodV;
  sum_user += bda_c2j_count_user.CallStaticLongMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticLongMethodA, bda_c2j_count_user.CallStaticLongMethodA, "CallStaticLongMethodA");  sum += bda_c2j_count.CallStaticLongMethodA;
  sum_user += bda_c2j_count_user.CallStaticLongMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticFloatMethod, bda_c2j_count_user.CallStaticFloatMethod, "CallStaticFloatMethod");  sum += bda_c2j_count.CallStaticFloatMethod;
  sum_user += bda_c2j_count_user.CallStaticFloatMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticFloatMethodV, bda_c2j_count_user.CallStaticFloatMethodV, "CallStaticFloatMethodV");  sum += bda_c2j_count.CallStaticFloatMethodV;
  sum_user += bda_c2j_count_user.CallStaticFloatMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticFloatMethodA, bda_c2j_count_user.CallStaticFloatMethodA, "CallStaticFloatMethodA");  sum += bda_c2j_count.CallStaticFloatMethodA;
  sum_user += bda_c2j_count_user.CallStaticFloatMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticDoubleMethod, bda_c2j_count_user.CallStaticDoubleMethod, "CallStaticDoubleMethod");  sum += bda_c2j_count.CallStaticDoubleMethod;
  sum_user += bda_c2j_count_user.CallStaticDoubleMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticDoubleMethodV, bda_c2j_count_user.CallStaticDoubleMethodV, "CallStaticDoubleMethodV");  sum += bda_c2j_count.CallStaticDoubleMethodV;
  sum_user += bda_c2j_count_user.CallStaticDoubleMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticDoubleMethodA, bda_c2j_count_user.CallStaticDoubleMethodA, "CallStaticDoubleMethodA");  sum += bda_c2j_count.CallStaticDoubleMethodA;
  sum_user += bda_c2j_count_user.CallStaticDoubleMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticVoidMethod, bda_c2j_count_user.CallStaticVoidMethod, "CallStaticVoidMethod");  sum += bda_c2j_count.CallStaticVoidMethod;
  sum_user += bda_c2j_count_user.CallStaticVoidMethod;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticVoidMethodV, bda_c2j_count_user.CallStaticVoidMethodV, "CallStaticVoidMethodV");  sum += bda_c2j_count.CallStaticVoidMethodV;
  sum_user += bda_c2j_count_user.CallStaticVoidMethodV;
  printf("%7d %7d %s\n", bda_c2j_count.CallStaticVoidMethodA, bda_c2j_count_user.CallStaticVoidMethodA, "CallStaticVoidMethodA");  sum += bda_c2j_count.CallStaticVoidMethodA;
  sum_user += bda_c2j_count_user.CallStaticVoidMethodA;
  printf("%7d %7d %s\n", bda_c2j_count.GetStaticFieldID, bda_c2j_count_user.GetStaticFieldID, "GetStaticFieldID");  sum += bda_c2j_count.GetStaticFieldID;
  sum_user += bda_c2j_count_user.GetStaticFieldID;
  printf("%7d %7d %s\n", bda_c2j_count.GetStaticObjectField, bda_c2j_count_user.GetStaticObjectField, "GetStaticObjectField");  sum += bda_c2j_count.GetStaticObjectField;
  sum_user += bda_c2j_count_user.GetStaticObjectField;
  printf("%7d %7d %s\n", bda_c2j_count.GetStaticBooleanField, bda_c2j_count_user.GetStaticBooleanField, "GetStaticBooleanField");  sum += bda_c2j_count.GetStaticBooleanField;
  sum_user += bda_c2j_count_user.GetStaticBooleanField;
  printf("%7d %7d %s\n", bda_c2j_count.GetStaticByteField, bda_c2j_count_user.GetStaticByteField, "GetStaticByteField");  sum += bda_c2j_count.GetStaticByteField;
  sum_user += bda_c2j_count_user.GetStaticByteField;
  printf("%7d %7d %s\n", bda_c2j_count.GetStaticCharField, bda_c2j_count_user.GetStaticCharField, "GetStaticCharField");  sum += bda_c2j_count.GetStaticCharField;
  sum_user += bda_c2j_count_user.GetStaticCharField;
  printf("%7d %7d %s\n", bda_c2j_count.GetStaticShortField, bda_c2j_count_user.GetStaticShortField, "GetStaticShortField");  sum += bda_c2j_count.GetStaticShortField;
  sum_user += bda_c2j_count_user.GetStaticShortField;
  printf("%7d %7d %s\n", bda_c2j_count.GetStaticIntField, bda_c2j_count_user.GetStaticIntField, "GetStaticIntField");  sum += bda_c2j_count.GetStaticIntField;
  sum_user += bda_c2j_count_user.GetStaticIntField;
  printf("%7d %7d %s\n", bda_c2j_count.GetStaticLongField, bda_c2j_count_user.GetStaticLongField, "GetStaticLongField");  sum += bda_c2j_count.GetStaticLongField;
  sum_user += bda_c2j_count_user.GetStaticLongField;
  printf("%7d %7d %s\n", bda_c2j_count.GetStaticFloatField, bda_c2j_count_user.GetStaticFloatField, "GetStaticFloatField");  sum += bda_c2j_count.GetStaticFloatField;
  sum_user += bda_c2j_count_user.GetStaticFloatField;
  printf("%7d %7d %s\n", bda_c2j_count.GetStaticDoubleField, bda_c2j_count_user.GetStaticDoubleField, "GetStaticDoubleField");  sum += bda_c2j_count.GetStaticDoubleField;
  sum_user += bda_c2j_count_user.GetStaticDoubleField;
  printf("%7d %7d %s\n", bda_c2j_count.SetStaticObjectField, bda_c2j_count_user.SetStaticObjectField, "SetStaticObjectField");  sum += bda_c2j_count.SetStaticObjectField;
  sum_user += bda_c2j_count_user.SetStaticObjectField;
  printf("%7d %7d %s\n", bda_c2j_count.SetStaticBooleanField, bda_c2j_count_user.SetStaticBooleanField, "SetStaticBooleanField");  sum += bda_c2j_count.SetStaticBooleanField;
  sum_user += bda_c2j_count_user.SetStaticBooleanField;
  printf("%7d %7d %s\n", bda_c2j_count.SetStaticByteField, bda_c2j_count_user.SetStaticByteField, "SetStaticByteField");  sum += bda_c2j_count.SetStaticByteField;
  sum_user += bda_c2j_count_user.SetStaticByteField;
  printf("%7d %7d %s\n", bda_c2j_count.SetStaticCharField, bda_c2j_count_user.SetStaticCharField, "SetStaticCharField");  sum += bda_c2j_count.SetStaticCharField;
  sum_user += bda_c2j_count_user.SetStaticCharField;
  printf("%7d %7d %s\n", bda_c2j_count.SetStaticShortField, bda_c2j_count_user.SetStaticShortField, "SetStaticShortField");  sum += bda_c2j_count.SetStaticShortField;
  sum_user += bda_c2j_count_user.SetStaticShortField;
  printf("%7d %7d %s\n", bda_c2j_count.SetStaticIntField, bda_c2j_count_user.SetStaticIntField, "SetStaticIntField");  sum += bda_c2j_count.SetStaticIntField;
  sum_user += bda_c2j_count_user.SetStaticIntField;
  printf("%7d %7d %s\n", bda_c2j_count.SetStaticLongField, bda_c2j_count_user.SetStaticLongField, "SetStaticLongField");  sum += bda_c2j_count.SetStaticLongField;
  sum_user += bda_c2j_count_user.SetStaticLongField;
  printf("%7d %7d %s\n", bda_c2j_count.SetStaticFloatField, bda_c2j_count_user.SetStaticFloatField, "SetStaticFloatField");  sum += bda_c2j_count.SetStaticFloatField;
  sum_user += bda_c2j_count_user.SetStaticFloatField;
  printf("%7d %7d %s\n", bda_c2j_count.SetStaticDoubleField, bda_c2j_count_user.SetStaticDoubleField, "SetStaticDoubleField");  sum += bda_c2j_count.SetStaticDoubleField;
  sum_user += bda_c2j_count_user.SetStaticDoubleField;
  printf("%7d %7d %s\n", bda_c2j_count.NewString, bda_c2j_count_user.NewString, "NewString");  sum += bda_c2j_count.NewString;
  sum_user += bda_c2j_count_user.NewString;
  printf("%7d %7d %s\n", bda_c2j_count.GetStringLength, bda_c2j_count_user.GetStringLength, "GetStringLength");  sum += bda_c2j_count.GetStringLength;
  sum_user += bda_c2j_count_user.GetStringLength;
  printf("%7d %7d %s\n", bda_c2j_count.GetStringChars, bda_c2j_count_user.GetStringChars, "GetStringChars");  sum += bda_c2j_count.GetStringChars;
  sum_user += bda_c2j_count_user.GetStringChars;
  printf("%7d %7d %s\n", bda_c2j_count.ReleaseStringChars, bda_c2j_count_user.ReleaseStringChars, "ReleaseStringChars");  sum += bda_c2j_count.ReleaseStringChars;
  sum_user += bda_c2j_count_user.ReleaseStringChars;
  printf("%7d %7d %s\n", bda_c2j_count.NewStringUTF, bda_c2j_count_user.NewStringUTF, "NewStringUTF");  sum += bda_c2j_count.NewStringUTF;
  sum_user += bda_c2j_count_user.NewStringUTF;
  printf("%7d %7d %s\n", bda_c2j_count.GetStringUTFLength, bda_c2j_count_user.GetStringUTFLength, "GetStringUTFLength");  sum += bda_c2j_count.GetStringUTFLength;
  sum_user += bda_c2j_count_user.GetStringUTFLength;
  printf("%7d %7d %s\n", bda_c2j_count.GetStringUTFChars, bda_c2j_count_user.GetStringUTFChars, "GetStringUTFChars");  sum += bda_c2j_count.GetStringUTFChars;
  sum_user += bda_c2j_count_user.GetStringUTFChars;
  printf("%7d %7d %s\n", bda_c2j_count.ReleaseStringUTFChars, bda_c2j_count_user.ReleaseStringUTFChars, "ReleaseStringUTFChars");  sum += bda_c2j_count.ReleaseStringUTFChars;
  sum_user += bda_c2j_count_user.ReleaseStringUTFChars;
  printf("%7d %7d %s\n", bda_c2j_count.GetArrayLength, bda_c2j_count_user.GetArrayLength, "GetArrayLength");  sum += bda_c2j_count.GetArrayLength;
  sum_user += bda_c2j_count_user.GetArrayLength;
  printf("%7d %7d %s\n", bda_c2j_count.NewObjectArray, bda_c2j_count_user.NewObjectArray, "NewObjectArray");  sum += bda_c2j_count.NewObjectArray;
  sum_user += bda_c2j_count_user.NewObjectArray;
  printf("%7d %7d %s\n", bda_c2j_count.GetObjectArrayElement, bda_c2j_count_user.GetObjectArrayElement, "GetObjectArrayElement");  sum += bda_c2j_count.GetObjectArrayElement;
  sum_user += bda_c2j_count_user.GetObjectArrayElement;
  printf("%7d %7d %s\n", bda_c2j_count.SetObjectArrayElement, bda_c2j_count_user.SetObjectArrayElement, "SetObjectArrayElement");  sum += bda_c2j_count.SetObjectArrayElement;
  sum_user += bda_c2j_count_user.SetObjectArrayElement;
  printf("%7d %7d %s\n", bda_c2j_count.NewBooleanArray, bda_c2j_count_user.NewBooleanArray, "NewBooleanArray");  sum += bda_c2j_count.NewBooleanArray;
  sum_user += bda_c2j_count_user.NewBooleanArray;
  printf("%7d %7d %s\n", bda_c2j_count.NewByteArray, bda_c2j_count_user.NewByteArray, "NewByteArray");  sum += bda_c2j_count.NewByteArray;
  sum_user += bda_c2j_count_user.NewByteArray;
  printf("%7d %7d %s\n", bda_c2j_count.NewCharArray, bda_c2j_count_user.NewCharArray, "NewCharArray");  sum += bda_c2j_count.NewCharArray;
  sum_user += bda_c2j_count_user.NewCharArray;
  printf("%7d %7d %s\n", bda_c2j_count.NewShortArray, bda_c2j_count_user.NewShortArray, "NewShortArray");  sum += bda_c2j_count.NewShortArray;
  sum_user += bda_c2j_count_user.NewShortArray;
  printf("%7d %7d %s\n", bda_c2j_count.NewIntArray, bda_c2j_count_user.NewIntArray, "NewIntArray");  sum += bda_c2j_count.NewIntArray;
  sum_user += bda_c2j_count_user.NewIntArray;
  printf("%7d %7d %s\n", bda_c2j_count.NewLongArray, bda_c2j_count_user.NewLongArray, "NewLongArray");  sum += bda_c2j_count.NewLongArray;
  sum_user += bda_c2j_count_user.NewLongArray;
  printf("%7d %7d %s\n", bda_c2j_count.NewFloatArray, bda_c2j_count_user.NewFloatArray, "NewFloatArray");  sum += bda_c2j_count.NewFloatArray;
  sum_user += bda_c2j_count_user.NewFloatArray;
  printf("%7d %7d %s\n", bda_c2j_count.NewDoubleArray, bda_c2j_count_user.NewDoubleArray, "NewDoubleArray");  sum += bda_c2j_count.NewDoubleArray;
  sum_user += bda_c2j_count_user.NewDoubleArray;
  printf("%7d %7d %s\n", bda_c2j_count.GetBooleanArrayElements, bda_c2j_count_user.GetBooleanArrayElements, "GetBooleanArrayElements");  sum += bda_c2j_count.GetBooleanArrayElements;
  sum_user += bda_c2j_count_user.GetBooleanArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.GetByteArrayElements, bda_c2j_count_user.GetByteArrayElements, "GetByteArrayElements");  sum += bda_c2j_count.GetByteArrayElements;
  sum_user += bda_c2j_count_user.GetByteArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.GetCharArrayElements, bda_c2j_count_user.GetCharArrayElements, "GetCharArrayElements");  sum += bda_c2j_count.GetCharArrayElements;
  sum_user += bda_c2j_count_user.GetCharArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.GetShortArrayElements, bda_c2j_count_user.GetShortArrayElements, "GetShortArrayElements");  sum += bda_c2j_count.GetShortArrayElements;
  sum_user += bda_c2j_count_user.GetShortArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.GetIntArrayElements, bda_c2j_count_user.GetIntArrayElements, "GetIntArrayElements");  sum += bda_c2j_count.GetIntArrayElements;
  sum_user += bda_c2j_count_user.GetIntArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.GetLongArrayElements, bda_c2j_count_user.GetLongArrayElements, "GetLongArrayElements");  sum += bda_c2j_count.GetLongArrayElements;
  sum_user += bda_c2j_count_user.GetLongArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.GetFloatArrayElements, bda_c2j_count_user.GetFloatArrayElements, "GetFloatArrayElements");  sum += bda_c2j_count.GetFloatArrayElements;
  sum_user += bda_c2j_count_user.GetFloatArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.GetDoubleArrayElements, bda_c2j_count_user.GetDoubleArrayElements, "GetDoubleArrayElements");  sum += bda_c2j_count.GetDoubleArrayElements;
  sum_user += bda_c2j_count_user.GetDoubleArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.ReleaseBooleanArrayElements, bda_c2j_count_user.ReleaseBooleanArrayElements, "ReleaseBooleanArrayElements");  sum += bda_c2j_count.ReleaseBooleanArrayElements;
  sum_user += bda_c2j_count_user.ReleaseBooleanArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.ReleaseByteArrayElements, bda_c2j_count_user.ReleaseByteArrayElements, "ReleaseByteArrayElements");  sum += bda_c2j_count.ReleaseByteArrayElements;
  sum_user += bda_c2j_count_user.ReleaseByteArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.ReleaseCharArrayElements, bda_c2j_count_user.ReleaseCharArrayElements, "ReleaseCharArrayElements");  sum += bda_c2j_count.ReleaseCharArrayElements;
  sum_user += bda_c2j_count_user.ReleaseCharArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.ReleaseShortArrayElements, bda_c2j_count_user.ReleaseShortArrayElements, "ReleaseShortArrayElements");  sum += bda_c2j_count.ReleaseShortArrayElements;
  sum_user += bda_c2j_count_user.ReleaseShortArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.ReleaseIntArrayElements, bda_c2j_count_user.ReleaseIntArrayElements, "ReleaseIntArrayElements");  sum += bda_c2j_count.ReleaseIntArrayElements;
  sum_user += bda_c2j_count_user.ReleaseIntArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.ReleaseLongArrayElements, bda_c2j_count_user.ReleaseLongArrayElements, "ReleaseLongArrayElements");  sum += bda_c2j_count.ReleaseLongArrayElements;
  sum_user += bda_c2j_count_user.ReleaseLongArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.ReleaseFloatArrayElements, bda_c2j_count_user.ReleaseFloatArrayElements, "ReleaseFloatArrayElements");  sum += bda_c2j_count.ReleaseFloatArrayElements;
  sum_user += bda_c2j_count_user.ReleaseFloatArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.ReleaseDoubleArrayElements, bda_c2j_count_user.ReleaseDoubleArrayElements, "ReleaseDoubleArrayElements");  sum += bda_c2j_count.ReleaseDoubleArrayElements;
  sum_user += bda_c2j_count_user.ReleaseDoubleArrayElements;
  printf("%7d %7d %s\n", bda_c2j_count.GetBooleanArrayRegion, bda_c2j_count_user.GetBooleanArrayRegion, "GetBooleanArrayRegion");  sum += bda_c2j_count.GetBooleanArrayRegion;
  sum_user += bda_c2j_count_user.GetBooleanArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.GetByteArrayRegion, bda_c2j_count_user.GetByteArrayRegion, "GetByteArrayRegion");  sum += bda_c2j_count.GetByteArrayRegion;
  sum_user += bda_c2j_count_user.GetByteArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.GetCharArrayRegion, bda_c2j_count_user.GetCharArrayRegion, "GetCharArrayRegion");  sum += bda_c2j_count.GetCharArrayRegion;
  sum_user += bda_c2j_count_user.GetCharArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.GetShortArrayRegion, bda_c2j_count_user.GetShortArrayRegion, "GetShortArrayRegion");  sum += bda_c2j_count.GetShortArrayRegion;
  sum_user += bda_c2j_count_user.GetShortArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.GetIntArrayRegion, bda_c2j_count_user.GetIntArrayRegion, "GetIntArrayRegion");  sum += bda_c2j_count.GetIntArrayRegion;
  sum_user += bda_c2j_count_user.GetIntArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.GetLongArrayRegion, bda_c2j_count_user.GetLongArrayRegion, "GetLongArrayRegion");  sum += bda_c2j_count.GetLongArrayRegion;
  sum_user += bda_c2j_count_user.GetLongArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.GetFloatArrayRegion, bda_c2j_count_user.GetFloatArrayRegion, "GetFloatArrayRegion");  sum += bda_c2j_count.GetFloatArrayRegion;
  sum_user += bda_c2j_count_user.GetFloatArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.GetDoubleArrayRegion, bda_c2j_count_user.GetDoubleArrayRegion, "GetDoubleArrayRegion");  sum += bda_c2j_count.GetDoubleArrayRegion;
  sum_user += bda_c2j_count_user.GetDoubleArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.SetBooleanArrayRegion, bda_c2j_count_user.SetBooleanArrayRegion, "SetBooleanArrayRegion");  sum += bda_c2j_count.SetBooleanArrayRegion;
  sum_user += bda_c2j_count_user.SetBooleanArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.SetByteArrayRegion, bda_c2j_count_user.SetByteArrayRegion, "SetByteArrayRegion");  sum += bda_c2j_count.SetByteArrayRegion;
  sum_user += bda_c2j_count_user.SetByteArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.SetCharArrayRegion, bda_c2j_count_user.SetCharArrayRegion, "SetCharArrayRegion");  sum += bda_c2j_count.SetCharArrayRegion;
  sum_user += bda_c2j_count_user.SetCharArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.SetShortArrayRegion, bda_c2j_count_user.SetShortArrayRegion, "SetShortArrayRegion");  sum += bda_c2j_count.SetShortArrayRegion;
  sum_user += bda_c2j_count_user.SetShortArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.SetIntArrayRegion, bda_c2j_count_user.SetIntArrayRegion, "SetIntArrayRegion");  sum += bda_c2j_count.SetIntArrayRegion;
  sum_user += bda_c2j_count_user.SetIntArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.SetLongArrayRegion, bda_c2j_count_user.SetLongArrayRegion, "SetLongArrayRegion");  sum += bda_c2j_count.SetLongArrayRegion;
  sum_user += bda_c2j_count_user.SetLongArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.SetFloatArrayRegion, bda_c2j_count_user.SetFloatArrayRegion, "SetFloatArrayRegion");  sum += bda_c2j_count.SetFloatArrayRegion;
  sum_user += bda_c2j_count_user.SetFloatArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.SetDoubleArrayRegion, bda_c2j_count_user.SetDoubleArrayRegion, "SetDoubleArrayRegion");  sum += bda_c2j_count.SetDoubleArrayRegion;
  sum_user += bda_c2j_count_user.SetDoubleArrayRegion;
  printf("%7d %7d %s\n", bda_c2j_count.RegisterNatives, bda_c2j_count_user.RegisterNatives, "RegisterNatives");  sum += bda_c2j_count.RegisterNatives;
  sum_user += bda_c2j_count_user.RegisterNatives;
  printf("%7d %7d %s\n", bda_c2j_count.UnregisterNatives, bda_c2j_count_user.UnregisterNatives, "UnregisterNatives");  sum += bda_c2j_count.UnregisterNatives;
  sum_user += bda_c2j_count_user.UnregisterNatives;
  printf("%7d %7d %s\n", bda_c2j_count.MonitorEnter, bda_c2j_count_user.MonitorEnter, "MonitorEnter");  sum += bda_c2j_count.MonitorEnter;
  sum_user += bda_c2j_count_user.MonitorEnter;
  printf("%7d %7d %s\n", bda_c2j_count.MonitorExit, bda_c2j_count_user.MonitorExit, "MonitorExit");  sum += bda_c2j_count.MonitorExit;
  sum_user += bda_c2j_count_user.MonitorExit;
  printf("%7d %7d %s\n", bda_c2j_count.GetJavaVM, bda_c2j_count_user.GetJavaVM, "GetJavaVM");  sum += bda_c2j_count.GetJavaVM;
  sum_user += bda_c2j_count_user.GetJavaVM;
  printf("%7d %7d %s\n", bda_c2j_count.GetStringRegion, bda_c2j_count_user.GetStringRegion, "GetStringRegion");  sum += bda_c2j_count.GetStringRegion;
  sum_user += bda_c2j_count_user.GetStringRegion;
  printf("%7d %7d %s\n", bda_c2j_count.GetStringUTFRegion, bda_c2j_count_user.GetStringUTFRegion, "GetStringUTFRegion");  sum += bda_c2j_count.GetStringUTFRegion;
  sum_user += bda_c2j_count_user.GetStringUTFRegion;
  printf("%7d %7d %s\n", bda_c2j_count.GetPrimitiveArrayCritical, bda_c2j_count_user.GetPrimitiveArrayCritical, "GetPrimitiveArrayCritical");  sum += bda_c2j_count.GetPrimitiveArrayCritical;
  sum_user += bda_c2j_count_user.GetPrimitiveArrayCritical;
  printf("%7d %7d %s\n", bda_c2j_count.ReleasePrimitiveArrayCritical, bda_c2j_count_user.ReleasePrimitiveArrayCritical, "ReleasePrimitiveArrayCritical");  sum += bda_c2j_count.ReleasePrimitiveArrayCritical;
  sum_user += bda_c2j_count_user.ReleasePrimitiveArrayCritical;
  printf("%7d %7d %s\n", bda_c2j_count.GetStringCritical, bda_c2j_count_user.GetStringCritical, "GetStringCritical");  sum += bda_c2j_count.GetStringCritical;
  sum_user += bda_c2j_count_user.GetStringCritical;
  printf("%7d %7d %s\n", bda_c2j_count.ReleaseStringCritical, bda_c2j_count_user.ReleaseStringCritical, "ReleaseStringCritical");  sum += bda_c2j_count.ReleaseStringCritical;
  sum_user += bda_c2j_count_user.ReleaseStringCritical;
  printf("%7d %7d %s\n", bda_c2j_count.NewWeakGlobalRef, bda_c2j_count_user.NewWeakGlobalRef, "NewWeakGlobalRef");  sum += bda_c2j_count.NewWeakGlobalRef;
  sum_user += bda_c2j_count_user.NewWeakGlobalRef;
  printf("%7d %7d %s\n", bda_c2j_count.DeleteWeakGlobalRef, bda_c2j_count_user.DeleteWeakGlobalRef, "DeleteWeakGlobalRef");  sum += bda_c2j_count.DeleteWeakGlobalRef;
  sum_user += bda_c2j_count_user.DeleteWeakGlobalRef;
  printf("%7d %7d %s\n", bda_c2j_count.ExceptionCheck, bda_c2j_count_user.ExceptionCheck, "ExceptionCheck");  sum += bda_c2j_count.ExceptionCheck;
  sum_user += bda_c2j_count_user.ExceptionCheck;
  printf("%7d %7d %s\n", bda_c2j_count.NewDirectByteBuffer, bda_c2j_count_user.NewDirectByteBuffer, "NewDirectByteBuffer");  sum += bda_c2j_count.NewDirectByteBuffer;
  sum_user += bda_c2j_count_user.NewDirectByteBuffer;
  printf("%7d %7d %s\n", bda_c2j_count.GetDirectBufferAddress, bda_c2j_count_user.GetDirectBufferAddress, "GetDirectBufferAddress");  sum += bda_c2j_count.GetDirectBufferAddress;
  sum_user += bda_c2j_count_user.GetDirectBufferAddress;
  printf("%7d %7d %s\n", bda_c2j_count.GetDirectBufferCapacity, bda_c2j_count_user.GetDirectBufferCapacity, "GetDirectBufferCapacity");  sum += bda_c2j_count.GetDirectBufferCapacity;
  sum_user += bda_c2j_count_user.GetDirectBufferCapacity;
  printf("%7d %7d %s\n", bda_c2j_count.GetObjectRefType, bda_c2j_count_user.GetObjectRefType, "GetObjectRefType");  sum += bda_c2j_count.GetObjectRefType;
  sum_user += bda_c2j_count_user.GetObjectRefType;
  printf("%10d %10d %s\n", sum, sum_user, "JNI Function call counts");
}
